#!/bin/bash
#
#  Copyright (C) 2003 Dell Computer Corporation <gary_lerhaupt@dell.com>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#  Dynamic Kernel Module Support (DKMS)
#  by Gary Lerhaupt <gary_lerhaupt@dell.com>

function invoke_command ()
{
    local exitval=0
    local exitval_file=`mktemp $tmp_location/dkms.XXXXXX`
    echo -en "$2..." 
    if [ "$3" == background ]; then
	(eval $1; echo "exitval=$?" >> "$exitval_file") &
	while [ -e "$exitval_file" ] && ! [ -s "$exitval_file" ]; do
	    sleep 3
	    echo -en "." 
	done
	. "$exitval_file"
    else
	eval $1; exitval=$?
    fi
    [ $exitval -gt 0 ] && echo -en "(bad exit status: $exitval)"
    rm -f "$exitval_file"
    echo -en "\n" 
    return $exitval
}

function show_usage ()
{
    echo $"Usage: $0 [action] [options]" 
    echo $"  [action]  = { add | remove | build | install | uninstall | match" 
    echo $"               | mkdriverdisk | mktarball | ldtarball | mkrpm | status }" 
    echo $"  [options] = [-m module] [-v module-version] [-k kernel-version] [-a arch]" 
    echo $"              [-d distro] [-c dkms.conf-location] [-q] [--force] [--all]" 
    echo $"              [--templatekernel=kernel] [--directive='cli-directive=cli-value']"  
    echo $"              [--config=kernel-.config-location] [--archive=tarball-location]"  
}

function readlink()
{
    # $1 = the symlink to read
    read_link=""
    if [ -L "$1" ]; then
	read_link="$1"
	while [ -L "$read_link" ]; do
	    read_link=`ls -l $read_link | sed 's/.*-> //'`
	done
    fi
}

function version_checker()
{
    local ver1=$1
    while [ `echo $ver1 | egrep -c [^0123456789.]` -gt 0 ]; do
	char=`echo $ver1 | sed 's/.*\([^0123456789.]\).*/\1/'`
	char_dec=`echo -n "$char" | od -b | head -1 | awk {'print $2'}`
	ver1=`echo $ver1 | sed "s/$char/.$char_dec/g"`
    done
    local ver2=$2
    while [ `echo $ver2 | egrep -c [^0123456789.]` -gt 0 ]; do
	char=`echo $ver2 | sed 's/.*\([^0123456789.]\).*/\1/'`
	char_dec=`echo -n "$char" | od -b | head -1 | awk {'print $2'}`
	ver2=`echo $ver2 | sed "s/$char/.$char_dec/g"`
    done
    
    ver1=`echo $ver1 | sed 's/\.\./.0/g'`
    ver2=`echo $ver2 | sed 's/\.\./.0/g'`
    
    do_version_check "$ver1" "$ver2"
}

function do_version_check() 
{
    [ "$1" == "$2" ] && return 10
    
    ver1front=`echo $1 | sed 's/\..*//'`
    ver1back=`echo $1 | sed "s/$ver1front\.//"`
    ver2front=`echo $2 | sed 's/\..*//'`
    ver2back=`echo $2 | sed "s/$ver2front\.//"`
    
    if [ "$ver1front" != "$1" ] || [ "$ver2front" != "$2" ]; then
	[ "$ver1front" -gt "$ver2front" ] && return 11
	[ "$ver1front" -lt "$ver2front" ] && return 9
	
	[ "$ver1front" == "$1" ] || [ -z "$ver1back" ] && ver1back=0
	[ "$ver2front" == "$2" ] || [ -z "$ver2back" ] && ver2back=0
                do_version_check "$ver1back" "$ver2back"
                return $?
    else
	[ "$1" -gt "$2" ] && return 11 || return 9
    fi
}

function set_module_suffix ()
{
    # $1 = the kernel to base the module_suffix on
    kernel_test="$1"
    [ -z "$kernel_test" ] && kernel_test=`uname -r`

    # Don't use version_checker because its too slow, just a hack here
    [ `echo "$kernel_test" | cut -d "." -f 1-1` -gt 1 ] && [ `echo "$kernel_test" | cut -d "." -f 2-2` -gt 4 ] && module_suffix=".ko" || module_suffix=".o"
}

function set_kernel_source_dir ()
{
    # $1 = the kernel to base the directory on
    if [ -z "$kernel_source_dir" ] && [ -d "$install_tree/$1/source" ]; then
        kernel_source_dir="$install_tree/$1/source"
    elif [ -z "$kernel_source_dir" ] && [ -d "$install_tree/$1/build" ]; then
        kernel_source_dir="$install_tree/$1/build"
    fi
}

function setup_kernels_arches ()
{
    # Error if # of arches doesn't match # of kernels
    if [ ${#kernelver_array[*]} -ne ${#arch_array[*]} ] && [ ${#arch_array[*]} -gt 1 ]; then
	echo $"" >>$std_err
	echo $"Error!  If more than one arch is specified on the command line, then there" >>$std_err
	echo $"must be an equal number of kernel versions also specified (1:1 relationship)." >>$std_err
	exit 1
    fi

    # Check that kernel version and all aren't both set simultaneously
    if [ -n "${kernelver_array[0]}" ] && [ -n "$all" ]; then
	echo $"" >>$std_err
	echo $"Error!  You cannot specify a kernel version and also specify" >>$std_err
	echo $"--all on the command line." >>$std_err
	exit 2
    fi

    # Check that arch and all aren't both set simultaneously
    if [ -n "${arch_array[0]}" ] && [ -n "$all" ]; then
	echo $"" >>$std_err
	echo $"Error!  You cannot specify an arch and also specify" >>$std_err
	echo $"--all on the command line." >>$std_err
	exit 3
    fi

    # Check that the actions supports multiple kernels
    if [ `echo "add build install match uninstall" | grep -c "$1\b"` -gt 0 ] && [ ${#kernelver_array[*]} -gt 1 ]; then
	echo $"" >>$std_err
	echo $"Error! The action $1 does not support multiple kernel version" >>$std_err
	echo $"parameters on the command line." >>$std_err
	exit 4
    fi

    # Check that the action supports --all
    if [ `echo "add build install match uninstall" | grep -c "$1\b"` -gt 0 ] && [ -n "$all" ]; then
	echo $"" >>$std_err
	echo $"Error! The action $1 does not support the --all" >>$std_err
	echo $"parameter." >>$std_err
	exit 5
    fi

    # If all is set, use dkms status to fill the arrays
    if [ -n "$all" ] && [ "$1" != "status" ]; then
	local i=0
	IFS='
'
	for line in `$0 status -m "$module" -v "$module_version" 2>/dev/null | egrep "built|installed"`; do
	    kernelver_array[$i]=`echo $line | awk {'print $3'} | sed 's/,$//'`
	    arch_array[$i]=`echo $line | awk {'print $4'} | sed 's/:$//'`
	    i=$(($i + 1))
	done
	unset IFS
    fi

    # Set default kernel version and arch, if none set
    if [ "$1" != "status" ]; then
	[ -z "${kernelver_array[0]}" ] && kernelver_array[0]=`uname -r`
	if [ -z "${arch_array[0]}" ]; then
	    if ! arch_array[0]=`rpm -qf --queryformat "%{ARCH}" "/lib/modules/${kernelver_array[0]}" 2>/dev/null`; then
		[ `uname -m` == "x86_64" ] && [ `cat /proc/cpuinfo | grep -c "Intel"` -gt 0 ] && [ `ls $install_tree/${kernelver_array[0]}/build/configs 2>/dev/null | grep -c "ia32e"` -gt 0 ] && arch_array[0]="ia32e" || arch_array[0]=`uname -m`
	    fi
	fi
    fi

    # If only one arch is specified, make it so for all the kernels
    if [ ${#arch_array[*]} -eq 1 ] && [ ${#kernelver_array[*]} -gt 1 ]; then
	while [ ${#arch_array[*]} -lt ${#kernelver_array[*]} ]; do
	    arch_array[${#arch_array[*]}]=${arch_array[0]}
	done
    fi

    # Set global multi_arch
    multi_arch=""
    local i=0
    while [ $i -lt ${#arch_array[*]} ]; do
	[ "${arch_array[0]}" != "${arch_array[$i]}" ] && multi_arch="true"
	i=$(($i + 1))
    done
}

function remake_initrd()
{
    # $1 = kernel version
    # $2 = arch

    local exitval="0"
    mkinitrd --version >/dev/null
    if [ "$?" -eq 0 ]; then
      	echo $"" 
	initrd_dir="/boot"
	[ "$2" == "ia64" ] && [ -d "/boot/efi/efi/redhat" ] && initrd_dir="/boot/efi/efi/redhat"
	echo $"Saving old initrd as $initrd_dir/initrd-$1_old.img" 
	cp -f "$initrd_dir/initrd-$1.img" "$initrd_dir/initrd-$1_old.img"
	echo $"Making new initrd as $initrd_dir/initrd-$1.img" 
	echo $"(If next boot fails, revert to the _old initrd image)"
	invoke_command "mkinitrd -f $initrd_dir/initrd-$1.img $1" "mkinitrd" background
	exitval="$?"
    elif [ -e /etc/SuSE-release ] || [ -d /etc/SuSEconfig ]; then
	echo $""
	initrd_dir="/boot"
	echo $"Saving old initrd as $initrd_dir/initrd-$1_old" 
	cp -f "$initrd_dir/initrd-$1" "$initrd_dir/initrd-$1_old"
	echo $"Making new initrd as $initrd_dir/initrd-$1" 
	echo $"(If next boot fails, revert to the _old initrd image)"
	invoke_command "mkinitrd -k vmlinuz-$1 -i initrd-$1" "mkinitrd" background
	exitval="$?"
    else
	echo $""
	echo $"Calling mkinitrd (bad exit status 9 may occur)"
	invoke_command "mkinitrd >/dev/null 2>&1" "mkinitrd" background
	exitval="$?"
    fi

    # Rerun lilo if necessary
    if ! [ -e /boot/grub/grub.conf ] && [ -e /etc/lilo.conf ] && ! [ -e /boot/grub/menu.lst ]; then
	invoke_command "/sbin/lilo" "Updating lilo"
    fi

    return $exitval
}

function read_conf ()
{
    # $1 kernel version (required)
    # $2 arch (required)
    # $3 dkms.conf location (optional)

    local return_value=0
    local read_conf_file

    # Find which conf file to check
    if [ -n "$3" ]; then
	read_conf_file="$3"
    elif [ -n "$conf" ]; then
	read_conf_file="$conf"
    else
	read_conf_file="$dkms_tree/$module/$module_version/source/dkms.conf"
    fi

    # Clear variables
    MAKE=""
    CLEAN=""
    REMAKE_INITRD=""
    remake_initrd=""
    PACKAGE_NAME=""
    PACKAGE_VERSION=""
    POST_ADD=""
    POST_BUILD=""
    POST_INSTALL=""
    POST_REMOVE=""
    PRE_BUILD=""
    BUILD_EXCLUSIVE_KERNEL=""
    BUILD_EXCLUSIVE_ARCH=""
    build_exclude=""

    # Clear arrays
    unset MAKE
    unset MAKE_MATCH
    unset MODULES_CONF
    unset modules_conf_array
    unset PATCH
    unset PATCH_MATCH
    unset patch_array
    unset BUILT_MODULE_NAME
    unset built_module_name
    unset BUILT_MODULE_LOCATION
    unset built_module_location
    unset DEST_MODULE_NAME
    unset dest_module_name
    unset DEST_MODULE_LOCATION
    unset dest_module_location
    unset MODULES_CONF_OBSOLETES
    unset modules_conf_obsoletes
    unset MODULES_CONF_ALIAS_TYPE
    unset modules_conf_alias_type
    unset MODULES_CONF_OBSOLETE_ONLY
    unset modules_conf_obsolete_only
    unset STRIP
    unset strip

    # Set variables supported in dkms.conf files (eg. $kernelver)
    kernelver="$1"
    arch="$2"
    set_kernel_source_dir "$1"
    
    # Source in the dkms.conf
    . $read_conf_file 2>/dev/null

    # Source in the directive_array
    IFS='
'
    for directive in "${directive_array[*]}"; do
	directive_name=`echo $directive | sed 's/\([^=]\+\)=.*/\1/'`
	directive_value=`echo $directive | sed 's/[^=]\+=//'`
	[ -n "$directive" ] && export $directive_name="$directive_value"
	[ -n "$directive" ] && echo $"DIRECTIVE: $directive_name=\"$directive_value\""
    done
    unset IFS

    # Set variables
    clean="$CLEAN"
    package_name="$PACKAGE_NAME"
    package_version="$PACKAGE_VERSION"
    post_add="$POST_ADD"
    post_build="$POST_BUILD"
    post_install="$POST_INSTALL"
    post_remove="$POST_REMOVE"
    pre_build="$PRE_BUILD"

    # Set module naming/location arrays
    local index=0
    array_size=`echo -e "${#BUILT_MODULE_NAME[*]}\n${#BUILT_MODULE_LOCATION[*]}\n${#DEST_MODULE_NAME[*]}\n${#DEST_MODULE_LOCATION[*]}\n" | sort -n | tail -1`
    while [ "$index" -lt "$array_size" ]; do
	# Set values
	built_module_name[$index]=${BUILT_MODULE_NAME[$index]}
	built_module_location[$index]=${BUILT_MODULE_LOCATION[$index]}
	dest_module_name[$index]=${DEST_MODULE_NAME[$index]}
	dest_module_location[$index]=${DEST_MODULE_LOCATION[$index]}
	modules_conf_obsoletes[$index]=${MODULES_CONF_OBSOLETES[$index]}
	modules_conf_alias_type[$index]=${MODULES_CONF_ALIAS_TYPE[$index]}
	[ `echo "${MODULES_CONF_OBSOLETE_ONLY[$index]}" | grep -ic "^y"` -gt 0 ] && modules_conf_obsolete_only[$index]="yes"
	[ `echo "${STRIP[$index]}" | grep -ic "^n"` -gt 0 ] && strip[$index]="no" || strip[$index]="yes"

	# If unset, set by defaults
	[ -z "${built_module_name[$index]}" ] && [ "${#DEST_MODULE_LOCATION[*]}" -eq 1 ] && built_module_name[$index]=$module
	[ -z "${dest_module_name[$index]}" ] && dest_module_name[$index]=${built_module_name[$index]}
	[ -n "${built_module_location[$index]}" ] && [ `echo ${built_module_location[$index]} | grep -c "\/$"` -eq 0 ] && built_module_location[$index]="${built_module_location[$index]}/"

	# FAIL if no built_module_name
	if [ -z "${built_module_name[$index]}" ]; then
	    echo $"dkms.conf: Error! No 'BUILT_MODULE_NAME' directive specified for record #$index." >>$std_err
	    return_value=1
	fi

	# FAIL if built_module_name has .o or .ko in it
	if [ `echo "${built_module_name[$index]}" | grep -c "\.k\?o$"` -gt 0 ]; then
	    echo $"dkms.conf: Error! 'BUILT_MODULE_NAME' directive includes phrase '.o' or '.ko' in record #$index." >>$std_err
	    return_value=1
	fi

	# FAIL if dest_module_name has .o or .ko in it
	if [ `echo "${dest_module_name[$index]}" | grep -c "\.k\?o$"` -gt 0 ]; then
	    echo $"dkms.conf: Error! 'DEST_MODULE_NAME' directive includes phrase '.o' or '.ko' in record #$index." >>$std_err
	    return_value=1
	fi
	
        # Fail if no DEST_MODULE_LOCATION 
	if [ -z "${DEST_MODULE_LOCATION[$index]}" ]; then
	    echo $"dkms.conf: Error! No 'DEST_MODULE_LOCATION' directive specified for record #$index.">>$std_err
	    return_value=1
	fi
	
        # Fail if bad DEST_MODULE_LOCATION
	if [ `echo "${DEST_MODULE_LOCATION[$index]}" | grep -c "^/kernel"` -eq 0 ]; then
	    echo $"dkms.conf: Error! Directive 'DEST_MODULE_LOCATION' does not begin with '/kernel' in record #$index.">>$std_err
	    return_value=1
	fi

	index=$(($index+1))
    done

    # Get the correct make command
    index=1
    make_command="${MAKE[0]}"
    while [ "$index" -lt "${#MAKE[*]}" ]; do
	if [ -n "${MAKE[$index]}" ] && [ -n "${MAKE_MATCH[$index]}" ] && [ `echo $1 | egrep -c "${MAKE_MATCH[$index]}"` -gt 0 ]; then
	    make_command="${MAKE[$index]}"
	fi
	index=$(($index+1))
    done

    # Use the generic make command if no make command has been specified
    if [ -z "$make_command" ]; then
	version_checker "$1" "2.6.6"
	if [ "$?" -eq 9 ]; then
	    make_command="make -C $kernel_source_dir SUBDIRS=$dkms_tree/$module/$module_version/build modules"
	    clean="make -C $kernel_source_dir SUBDIRS=$dkms_tree/$module/$module_version/build clean"
	else
	    make_command="make -C $kernel_source_dir M=$dkms_tree/$module/$module_version/build"
	    clean="make -C $kernel_source_dir M=$dkms_tree/$module/$module_version/build clean"
	fi
    fi
    
    # Set modules_conf_array
    index=0
    while [ "$index" -lt "${#MODULES_CONF[*]}" ]; do
	[ -n "${MODULES_CONF[$index]}" ] && modules_conf_array[$index]="${MODULES_CONF[$index]}"
	index=$(($index+1))
    done

    # Set patch_array (including kernel specific patches)
    index=0
    count=0
    while [ "$index" -lt "${#PATCH[*]}" ]; do
	if [ -z "${PATCH_MATCH[$index]}" ] || [ `echo $1 | egrep -c "${PATCH_MATCH[$index]}"` -gt 0 ]; then
	    patch_array[$count]="${PATCH[$index]}"
	    count=$(($count+1))
	fi
	index=$(($index+1))
    done

    # Set remake_initrd
    [ `echo "$REMAKE_INITRD" | grep -ic "^y"` -gt 0 ] && remake_initrd="yes"

    # Set build_exclude
    [ -n "$BUILD_EXCLUSIVE_KERNEL" ] && [ `echo $1 | egrep -c "$BUILD_EXCLUSIVE_KERNEL"` -eq 0 ] && build_exclude="yes"
    [ -n "$BUILD_EXCLUSIVE_ARCH" ] && [ `echo $2 | egrep -c "$BUILD_EXCLUSIVE_ARCH"` -eq 0 ] && build_exclude="yes"

    # Fail if absolutely no DEST_MODULE_LOCATION
    if [ "${#dest_module_location[*]}" -eq 0 ]; then
	echo $"dkms.conf: Error! No 'DEST_MODULE_LOCATION' directive specified." >>$std_err
	return_value=1
    fi

    # Fail if no PACKAGE_NAME
    if [ -z "$package_name" ]; then
	echo $"dkms.conf: Error! No 'PACKAGE_NAME' directive specified.">>$std_err
	return_value=1
    fi

    # Fail if no PACKAGE_VERSION
    if [ -z "$package_version" ]; then
	echo $"dkms.conf: Error! No 'PACKAGE_VERSION' directive specified.">>$std_err
	return_value=1
    fi

    # Set clean 
    [ -z "$clean" ] && clean="make clean"

    return $return_value
}


function check_version_sanity ()
{
    # $1 = kernel_version
    # $2 = arch

    local lib_tree="$install_tree/$1"
    local count=0
    echo $"Running module version sanity check."
    while [ "$count" -lt "${#built_module_name[*]}" ]; do
	local module_count=`find $lib_tree -name ${dest_module_name[$count]}$module_suffix | wc -l | awk {'print $1'}`
	if [ $module_count -gt 1 ]; then
	    echo $"Warning! Cannot do version sanity checking because multiple ${dest_module_name[$count]}$module_suffix" >>$std_err
	    echo $"modules were found in kernel $1." >>$std_err
	elif [ $module_count -eq 1 ]; then
	    local kernels_module=`find $lib_tree -name ${dest_module_name[$count]}$module_suffix`
	    local kernels_ver_string=`modinfo $kernels_module | grep "^version:"`
	    local kernels_ver_value=`echo $kernels_ver_string | awk {'print $2'}`
	    local kernels_ver_checksum=`echo $kernels_ver_string | awk {'print $3'}`
	    local dkms_module="$dkms_tree/$module/$module_version/$1/$2/module/${dest_module_name[$count]}$module_suffix"
	    local dkms_ver_string=`modinfo $dkms_module | grep "^version:"`
	    local dkms_ver_value=`echo $dkms_ver_string | awk {'print $2'}`
	    local dkms_ver_checksum=`echo $dkms_ver_string | awk {'print $3'}`	    
	    if [ -n "$kernels_ver_checksum" ] && [ -n "$dkms_ver_checksum" ]; then
		version_checker "$dkms_ver_value" "$kernels_ver_value"
		local returnval=$?
		if [ $returnval -lt 11 ] && [ -z "$force" ]; then
		    echo $"" >>$std_err
		    echo $"Error! Module version $dkms_ver_value for ${dest_module_name[$count]}$module_suffix" >>$std_err
		    echo $"is not newer than what is already found in kernel $1 ($kernels_ver_value)." >>$std_err
		    echo $"You may override by specifying --force." >>$std_err
		    exit 101
		fi
	    fi
	fi
	count=$(($count + 1))
    done
}


function moduleconfig_add ()
{
    # $1 = kernel version

    local temp_dir_name=`mktemp -d $tmp_location/dkms.XXXXXX`
    modconfig_files=""
    [ -e /etc/modules.conf ] && modconfig_files="/etc/modules.conf"
    [ -e /etc/modprobe.conf ] && modconfig_files="$modconfig_files /etc/modprobe.conf"

    for moduleconfig in $modconfig_files; do
	local index=0
	while [ $index -lt ${#dest_module_name[*]} ]; do
	    
  	    # Replace obsolete references in module-config-file with the new module name
	    if [ -n "${modules_conf_obsoletes[$index]}" ]; then
		for obsolete_module in `echo ${modules_conf_obsoletes[$index]} | tr ',' '\n'`; do
		    sed "s/\(alias ${modules_conf_alias_type[$index]}[0-9]*\) $obsolete_module$/\1 ${dest_module_name[$index]}/g" $moduleconfig > $temp_dir_name/moduleconfig.new
		    if ! `diff $moduleconfig $temp_dir_name/moduleconfig.new >/dev/null 2>&1`; then 
			cp -fp $temp_dir_name/moduleconfig.new $moduleconfig 2>/dev/null
			rm -f $temp_dir_name/moduleconfig.new 2>/dev/null
			echo $"$moduleconfig: obsolete alias '$obsolete_module' changed to '${dest_module_name[$index]}'"
		    fi
		done
	    fi
	    
	    # Only add it if it can't be found already in config file
	    if [ -n "${modules_conf_alias_type[$index]}" ] && [ `grep -c "alias ${modules_conf_alias_type[$index]}[0-9]* ${dest_module_name[$index]}\b" $moduleconfig` -eq 0 ] && [ "${modules_conf_obsolete_only[$index]}" != "yes" ]; then
		alias_number=$(( `grep "alias ${modules_conf_alias_type[$index]}" $moduleconfig | awk '{print $2}' | sed "s/${modules_conf_alias_type[$index]}//" | sort -n | tail -1` + 1 ))
		echo -e "alias ${modules_conf_alias_type[$index]}${alias_number} ${dest_module_name[$index]}" >> $moduleconfig
		echo $"$moduleconfig: added alias reference for '${dest_module_name[$index]}'"
	    fi
	    
	    index=$(($index+1))
	
	done
	
        # Add anything else
	index=0
	while [ $index -lt ${#modules_conf_array[*]} ]; do
	    if [ -n "${modules_conf_array[$index]}" ] && [ `grep -c "${modules_conf_array[$index]}" "$moduleconfig"` -eq 0 ]; then
		echo -e $"$moduleconfig: added '${modules_conf_array[$index]}'"
		echo -e "${modules_conf_array[$index]}" >> $moduleconfig
	    fi	    
	    index=$(($index+1))
	done
    done
	
    # Delete the temp dir
    rm -rf $temp_dir_name
}


function moduleconfig_remove ()
{
    # $1 = kernel version

    local temp_dir_name=`mktemp -d $tmp_location/dkms.XXXXXX`
    modconfig_files=""
    [ -e /etc/modules.conf ] && modconfig_files="/etc/modules.conf"
    [ -e /etc/modprobe.conf ] && modconfig_files="$modconfig_files /etc/modprobe.conf"

    for moduleconfig in $modconfig_files; do
	index=0
	while [ $index -lt ${#dest_module_name[*]} ]; do
	    
	# Remove/Replace aliases (maybe)
	    if [ -n "${modules_conf_alias_type[$index]}" ] && [ `find $install_tree/$1/ -name "${dest_module_name[$index]}.*" 2>/dev/null | wc -l | awk '{print $1}'` -eq 0 ]; then
		
		local conf_replacement=""
		for obsolete_module in `echo ${modules_conf_obsoletes[$index]} | tr ',' '\n'`; do
		    if [ `find $install_tree/$1/ -name "$obsolete_module.*" 2>/dev/null | wc -l | awk '{print $1}'` -gt 0 ] && [ -z "$conf_replacement" ]; then
			conf_replacement=$obsolete_module
		    fi
		done
		
		if [ -n "$conf_replacement" ] && [ `grep -c "alias ${modules_conf_alias_type[$index]}[0-9]* ${dest_module_name[$index]}$" $moduleconfig` -gt 0 ]; then
		    sed "s/\(alias ${modules_conf_alias_type[$index]}[0-9]*\) ${dest_module_name[$index]}$/\1 $conf_replacement/g" $moduleconfig > $temp_dir_name/moduleconfig.new
		    mv -f $temp_dir_name/moduleconfig.new $moduleconfig
		    echo $"$moduleconfig: alias for '${dest_module_name[$index]}' changed back to '$conf_replacement'"
		elif [ -z "$conf_replacement" ]; then
		    grep -v "alias ${modules_conf_alias_type}[0-9]* ${dest_module_name[$index]}" $moduleconfig > $temp_dir_name/moduleconfig.new
		    mv -f $temp_dir_name/moduleconfig.new $moduleconfig
		    echo $"$moduleconfig: removed alias for '${dest_module_name[$index]}'"
		fi
	    fi
	    
	    index=$(($index+1))
	done
	
        # Remove static conf entries
	index=0
	while [ $index -lt ${#modules_conf_array[*]} ]; do
	    if [ -n "${modules_conf_array[$index]}" ]; then
		grep -v "${modules_conf_array[$index]}" "$moduleconfig" > $temp_dir_name/moduleconfig.new
		echo $"$moduleconfig: removed '${modules_conf_array[$index]}'"
		mv -f $temp_dir_name/moduleconfig.new $moduleconfig
	    fi	    
	    index=$(($index+1))
	done
    done
    
    # Delete the temp dir
    rm -rf $temp_dir_name
}

function etc_sysconfig_kernel_modify ()
{
    # Make a temp directory to store files
    local temp_dir_name=`mktemp -d $tmp_location/dkms.XXXXXX`

    if [ -e "/etc/sysconfig/kernel" ] && [ -n "$remake_initrd" ]; then

        # Make /etc/sysconfig/kernel changes as necessary
	if [ "$1" == "add" ]; then
	    etc_sysconfig_kernel_modify "delete"
	    for module_name_after in ${dest_module_name[*]}; do
		sed -e "s/INITRD_MODULES=\"\(.*\)\"/INITRD_MODULES=\"\1 $module_name_after\"/" /etc/sysconfig/kernel > $temp_dir_name/kernel.new
		mv $temp_dir_name/kernel.new /etc/sysconfig/kernel
	    done
	
        # Remove /etc/sysconfig/kernel entries
	elif [ "$1" == "delete" ]; then
	    for module_name_after in ${dest_module_name[*]}; do
		sed -e "s/\(INITRD_MODULES.*\)$module_name_after\b\(.*\)/\1\2/" /etc/sysconfig/kernel > $temp_dir_name/kernel.new
		mv $temp_dir_name/kernel.new /etc/sysconfig/kernel
	    done
	fi
    fi

    # Delete the temp dir
    rm -rf $temp_dir_name
}

function add_module ()
{
    setup_kernels_arches "add"

    # Check that we have all the arguments
    if [ -z "$module" ] || [ -z "$module_version" ]; then
	echo $"" >>$std_err
	echo $"Error! Invalid number of arguments passed." >>$std_err
	echo $"Usage: add -m <module> -v <module-version>" >>$std_err
	exit 1
    fi

    if [ -z "$conf" ]; then
	conf="$source_tree/$module-$module_version/dkms.conf"
    fi
	
    # Check that /usr/src/$module-$module_version exists	
    if ! [ -d "$source_tree/$module-$module_version" ]; then
	echo $"" >>$std_err
	echo $"Error! Could not find module source directory." >>$std_err
	echo $"Directory: $source_tree/$module-$module_version does not exist." >>$std_err
	exit 2
    fi

    # Do stuff for --rpm_safe_upgrade
    if [ -n "$rpm_safe_upgrade" ]; then
	local pppid=`cat /proc/$PPID/status | grep PPid: | awk {'print $2'}`
	local temp_dir_name=`mktemp $tmp_location/dkms_rpm_safe_upgrade_lock.$pppid.XXXXXX 2>/dev/null`
	echo "$module-$module_version" >> $temp_dir_name
	ps -o lstart --no-headers -p $pppid 2>/dev/null >> $temp_dir_name
    fi

    # Check that this module-version hasn't already been added
    if [ -d "$dkms_tree/$module/$module_version" ]; then
	echo $"" >>$std_err
	echo $"Error! DKMS tree already contains: $module-$module_version" >>$std_err
	echo $"You cannot add the same module/version combo more than once." >>$std_err
	exit 3
    fi

    # Check that the conf file exists or any other script specified
    if ! [ -e "$conf" ]; then
	echo $"" >>$std_err
	echo $"Error! Could not locate dkms.conf file." >>$std_err
	echo $"File: $conf does not exist." >>$std_err
	exit 4
    fi

    # Check the conf file for sanity
    read_conf "${kernelver_array[0]}" "${arch_array[0]}" "$conf"
    if [ "$?" -ne 0 ]; then
	echo $"" >>$std_err
	echo $"Error! Bad conf file." >>$std_err
	echo $"File: $conf" >>$std_err
	echo $"does not represent a valid dkms.conf file." >>$std_err
	exit 8
    fi
    
    # Create the necessary dkms tree structure
    echo $""
    echo $"Creating symlink $dkms_tree/$module/$module_version/source ->"
    echo $"                 $source_tree/$module-$module_version"
    mkdir -p "$dkms_tree/$module/$module_version/build"
    ln -s "$source_tree/$module-$module_version" "$dkms_tree/$module/$module_version/source"
   
    # Run the post_add script
    if [ -n "$post_add" ] && [ -x `echo "$dkms_tree/$module/$module_version/source/$post_add" | sed 's/ .*//'` ]; then
	echo $"" 
	echo $"Running the post_add script:" 
	$dkms_tree/$module/$module_version/source/$post_add
    fi
    
    echo $"" 
    echo $"DKMS: add Completed." 
}

function prepare_kernel()
{
    # $1 = kernel version to prepare
    # $2 = arch to prepare

    set_kernel_source_dir "$1"

    # Check that kernel-source exists
    if ! [ -e "$kernel_source_dir/include" ]; then
	echo $"" >>$std_err
	echo $"Error! Your kernel source for kernel $1 cannot be found at" >>$std_err
	echo $"/lib/modules/$1/build or /lib/modules/$1/source." >>$std_err
	echo $"You can use the --kernelsourcedir option to tell DKMS where it's located."
	exit 1	
    fi

    # Prepare kernel for module build
    echo $"" 
    echo $"Preparing kernel $1 for module build:" 
    echo $"(This is not compiling a kernel, only just preparing kernel symbols)" 
    cd $kernel_source_dir
    config_contents=`cat .config 2>/dev/null`
    [ -n "$config_contents" ] && echo $"Storing current .config to be restored when complete"

    # Set kernel_config
    if [ -e /etc/redhat-release ] || [ -e /etc/fedora-release ]; then
	if [ -z "$kernel_config" ] && [ -d "$kernel_source_dir/configs" ]; then
	    local kernel_trunc=`echo $1 | sed 's/-.*//'`
	    for config_type in debug summit smp enterprise bigmem hugemem BOOT; do
		[ `echo "$1" | grep "$config_type"` ] && kernel_config="$kernel_source_dir/configs/kernel-$kernel_trunc-$2-$config_type.config"
		[ ! -e $kernel_config ] && kernel_config=""
	    done
	    [ -z "$kernel_config" ] && kernel_config="$kernel_source_dir/configs/kernel-$kernel_trunc-$2.config"
	    [ ! -e $kernel_config ] && kernel_config=""
	fi
    elif [ -e /etc/SuSE-release ] || [ -d /etc/SuSEconfig ]; then
        if [ -z "$kernel_config" ] && [ -d "$kernel_source_dir/arch" ]; then
     	    local kernel_trunc=`echo $1 | sed 's/-.*//'`
            if [ "$2" == "i586" ] || [ "$2" == "i686" ]; then
                config_arch="i386"
            else
                config_arch=$2
            fi
	    for config_type in default smp bigsmp; do
	        [ `echo "$1" | grep "$config_type"` ] && kernel_config="$kernel_source_dir/arch/$config_arch/defconfig.$config_type"
	        [ ! -e $kernel_config ] && kernel_config=""
	    done
	    [ -z "$kernel_config" ] && kernel_config="$kernel_source_dir/arch/$config_arch/defconfig.default"
	    [ ! -e $kernel_config ] && kernel_config=""
        fi
    fi
  
    # Do preparation
    if [ -e /boot/vmlinuz.version.h ]; then
	echo $"Running UnitedLinux preparation routine"
	local kernel_config="/boot/vmlinuz.config"
	invoke_command "make mrproper >/dev/null 2>&1" "make mrproper" background
	[ -n "$config_contents" ] && echo "$config_contents" > .config
	invoke_command "cp /boot/vmlinuz.version.h include/linux/version.h" "using /boot/vmlinux.version.h" 
	invoke_command "cp -f $kernel_config .config" "using $kernel_config" 
	invoke_command "make KERNELRELEASE=$1 cloneconfig >/dev/null 2>&1" "make cloneconfig" background
	invoke_command "make CONFIG_MODVERSIONS=1 KERNELRELEASE=$1 dep >/dev/null 2>&1" "make CONFIG_MODVERSIONS=1 dep" background
    elif `grep -q rhconfig.h $kernel_source_dir/include/linux/{modversions,version}.h 2>/dev/null`; then
	echo $"Running Red Hat style preparation routine"
	invoke_command "make clean >/dev/null 2>&1" "make clean" background
	[ -n "$config_contents" ] && echo "$config_contents" > .config

	if [ -n "$kernel_config" ]; then
	    echo $"using $kernel_config"
	    cp -f "$kernel_config" .config
	elif [ -e .config ]; then
	    echo $"using $kernel_source_dir/.config"
	    echo $"(I hope this is the correct config for this kernel)"
	else
	    echo $""
	    echo $"Warning! Cannot find a .config file to prepare your kernel with." >>$std_err
	    echo $"Try using the --config option to specify where one can be found." >>$std_err
	    echo $"Your build will likely fail because of this." >>$std_err
	fi

	# Hack to workaround broken tmp_include_depends for Red Hat
	if `grep -q "/usr/src/build" $kernel_source_dir/tmp_include_depends 2>/dev/null`; then
	    sed 's/\/usr\/src\/build\/.*\/install//g' $kernel_source_dir/tmp_include_depends > $kernel_source_dir/tmp_include_depends.new
	    mv -f $kernel_source_dir/tmp_include_depends.new $kernel_source_dir/tmp_include_depends
	fi

	invoke_command "make KERNELRELEASE=$1 oldconfig >/dev/null 2>&1" "make oldconfig" background
	kerneldoth_contents=`cat /boot/kernel.h 2>/dev/null`
	invoke_command "dkms_mkkerneldoth --kernelver $1 --targetarch $2 --output /boot/kernel.h" "running dkms_mkkerneldoth" background
    else 
	echo $"Running Generic preparation routine"
	invoke_command "make mrproper >/dev/null 2>&1" "make mrproper" background
	[ -n "$config_contents" ] && echo "$config_contents" > .config

	if [ -n "$kernel_config" ]; then
	    echo $"using $kernel_config"
	    cp -f "$kernel_config" .config
	elif [ -e .config ]; then
	    echo $"using $kernel_source_dir/.config"
	    echo $"(I hope this is the correct config for this kernel)"
	else
	    echo $""
	    echo $"Warning! Cannot find a .config file to prepare your kernel with." >>$std_err
	    echo $"Try using the --config option to specify where one can be found." >>$std_err
	    echo $"Your build will likely fail because of this." >>$std_err
	fi
	
	version_checker "$1" "2.5"
	local rv="$?"
	invoke_command "make KERNELRELEASE=$1 oldconfig >/dev/null 2>&1" "make oldconfig" background
	[ $rv -gt 9 ] && invoke_command "make KERNELRELEASE=$1 prepare-all scripts >/dev/null 2>&1" "make prepare-all" background
	[ $rv -eq 9 ] && invoke_command "make KERNELRELEASE=$1 dep >/dev/null 2>&1" "make dep" background
    fi
    cd -
}

function install_module()
{
    setup_kernels_arches "install"

    # Check that the right arguments were passed
    if [ -z "$module" ] || [ -z "$module_version" ]; then
	echo $"" >>$std_err
	echo $"Error! Invalid number of parameters passed." >>$std_err
	echo $"Usage: install -m <module> -v <module-version>" >>$std_err
	exit 1
    fi

    # Check that $module-$module_version exists by checking the source symlink	
    if ! [ -d "$dkms_tree/$module/$module_version/source" ]; then
	echo $"" >>$std_err
	echo $"Error! DKMS tree does not contain: $module-$module_version" >>$std_err
	echo $"Build cannot continue without the proper tree." >>$std_err
	exit 2
    fi

    # Make sure that kernel exists to install into
    if ! [ -e "$install_tree/${kernelver_array[0]}" ]; then
	echo $"" >>$std_err
	echo $"Error! The directory $install_tree/${kernelver_array[0]} doesn't exist." >>$std_err
	echo $"You cannot install a module onto a non-existant kernel." >>$std_err
	exit 6
    fi

    # Read the conf file
    read_conf "${kernelver_array[0]}" "${arch_array[0]}"
    if [ "$?" -ne 0 ]; then
	echo $"" >>$std_err
	echo $"Error! Bad conf file." >>$std_err
	echo $"Your dkms.conf is not valid." >>$std_err
	exit 3
    fi

    # Make sure the $module_name_after exists
    set_module_suffix "${kernelver_array[0]}"
    for module_name_after in ${dest_module_name[*]}; do
	if ! [ -e "$dkms_tree/$module/$module_version/${kernelver_array[0]}/${arch_array[0]}/module/$module_name_after$module_suffix" ]; then
	    echo $"" >>$std_err
	    echo $"Error! Could not locate $module_name_after$module_suffix for module $module in the DKMS tree." >>$std_err
	    echo $"You must run a dkms build for kernel ${kernelver_array[0]} (${arch_array[0]}) first." >>$std_err
	    exit 4
	fi
    done

    # Check that its not already installed (kernel symlink)
    readlink "$dkms_tree/$module/kernel-${kernelver_array[0]}-${arch_array[0]}"
    kernel_symlink="$read_link"
    if [ "$kernel_symlink" == "$module_version/${kernelver_array[0]}/${arch_array[0]}" ]; then
	echo $"" >>$std_err
	echo $"Error! This module/version combo is already installed" >>$std_err
	echo $"for kernel: ${kernelver_array[0]} (${arch_array[0]})" >>$std_err
	exit 5
    fi

    # Check this version against what is already in the kernel
    check_version_sanity "${kernelver_array[0]}" "${arch_array[0]}"

    # Save the original_module if one exists, none have been saved before, and this is the first module for this kernel
    local lib_tree="$install_tree/${kernelver_array[0]}"
    local count=0
    while [ "$count" -lt "${#built_module_name[*]}" ]; do
	echo $""
	echo $"${dest_module_name[$count]}$module_suffix:"
	local module_count=`find $lib_tree -name ${dest_module_name[$count]}$module_suffix | wc -l | awk {'print $1'}`
	echo $" - Original module"
	if ! [ -L "$dkms_tree/$module/kernel-${kernelver_array[0]}-${arch_array[0]}" ]; then
	    local archive_pref1="$lib_tree/updates/${dest_module_name[$count]}$module_suffix"
	    local archive_pref2="$lib_tree${dest_module_location[$count]}/${dest_module_name[$count]}$module_suffix"
	    [ "$module_count" -eq 1 ] && archive_pref3="`find $lib_tree -name ${dest_module_name[$count]}$module_suffix`"
	    local original_module=""
	    local found_orginal=""
	    for original_module in $archive_pref1 $archive_pref2 $archive_pref3; do
		if [ -e "$original_module" ]; then
		    echo $"   - Found $original_module"
		    echo $"   - Storing in $dkms_tree/$module/original_module/${kernelver_array[0]}/${arch_array[0]}/"
		    echo $"   - Archiving for uninstallation purposes"
		    mkdir -p "$dkms_tree/$module/original_module/${kernelver_array[0]}/${arch_array[0]}"
		    cp -f "$original_module" "$dkms_tree/$module/original_module/${kernelver_array[0]}/${arch_array[0]}/"
		    found_original="yes"
		    break
		fi
	    done
	    if [ -z "$found_original" ] && [ "$module_count" -gt 1 ]; then
		echo $"   - Multiple original modules exist but DKMS does not know which to pick"
		echo $"   - Due to the confusion, none will be considered during a later uninstall"
	    elif [ -z "$found_original" ]; then
		echo $"   - No original module exists within this kernel"
	    fi
	elif [ -L "$dkms_tree/$module/kernel-${kernelver_array[0]}-${arch_array[0]}" ] && [ -e "$dkms_tree/$module/original_module/${kernelver_array[0]}/${arch_array[0]}/${dest_module_name[$count]}$module_suffix" ]; then
	    echo $"   - An original module was already stored during a previous install"
	else
	    echo $"   - This kernel never originally had a module by this name"
	fi
	    
	if [ "$module_count" -gt 1 ]; then
	    echo $" - Multiple same named modules!"
	    echo $"   - $module_count named ${dest_module_name[$count]}$module_suffix in $lib_tree/"
	    echo $"   - All instances of this module will now be stored for reference purposes ONLY"
	    echo $"   - Storing in $dkms_tree/$module/original_module/${kernelver_array[0]}/${arch_array[0]}/collisions/"
	    for module_dup in `find $lib_tree -name ${dest_module_name[$count]}$module_suffix`; do
		dup_tree=`echo $module_dup | sed "s#^$lib_tree##" | sed "s#${dest_module_name[$count]}$module_suffix##"`
		echo $"     - Stored $module_dup"
		mkdir -p "$dkms_tree/$module/original_module/${kernelver_array[0]}/${arch_array[0]}/collisions/$dup_tree"
		mv -f $module_dup "$dkms_tree/$module/original_module/${kernelver_array[0]}/${arch_array[0]}/collisions/$dup_tree"
	    done
	fi

        # Copy module to its location
	echo $" - Installation"
 	echo $"   - Installing to $install_tree/${kernelver_array[0]}${dest_module_location[$count]}/" 
	mkdir -p $install_tree/${kernelver_array[0]}${dest_module_location[$count]}
	cp -f "$dkms_tree/$module/$module_version/${kernelver_array[0]}/${arch_array[0]}/module/${dest_module_name[$count]}$module_suffix" "$install_tree/${kernelver_array[0]}${dest_module_location[$count]}/${dest_module_name[$count]}$module_suffix"

	count=$(($count + 1))
    done
    
    # Create the kernel-<kernelver> symlink to designate this version as active
    rm -f "$dkms_tree/$module/kernel-${kernelver_array[0]}-${arch_array[0]}" 2>/dev/null
    ln -s "$module_version/${kernelver_array[0]}/${arch_array[0]}" "$dkms_tree/$module/kernel-${kernelver_array[0]}-${arch_array[0]}" 2>/dev/null

    # Run the post_install script
    if [ -n "$post_install" ] && [ -x `echo "$dkms_tree/$module/$module_version/source/$post_install" | sed 's/ .*//'` ]; then
	echo $""
	echo $"Running post_install:"  
	$dkms_tree/$module/$module_version/source/$post_install
    fi

    # Make modules.conf changes as necessary
    echo $""
    moduleconfig_add "${kernelver_array[0]}"
    etc_sysconfig_kernel_modify "add"

    # Run depmod if System.map-${kernelver_array[0]} exists
    if [ -e "/boot/System.map-${kernelver_array[0]}" ]; then
	invoke_command "depmod -au ${kernelver_array[0]} -F /boot/System.map-${kernelver_array[0]}" "depmod" background 
	if [ "$?" -ne 0 ]; then
	    local unresolved_symbols="`depmod -a ${kernelver_array[0]} -F /boot/System.map-${kernelver_array[0]} 2>&1`"
	    local count=0
	    while [ "$count" -lt "${#built_module_name[*]}" ]; do
		if [ `echo "$unresolved_symbols" | grep -c "${dest_module_name[$count]}$module_suffix$"` -gt 0 ]; then
		    echo $""
		    echo $"Problems with depmod detected.  Automatically uninstalling this module."
		    sleep 2
		    do_uninstall "${kernelver_array[0]}" "${arch_array[0]}"
		    echo $""
		    echo $"DKMS: Install Failed (depmod problems).  Module rolled back to built state."
		    exit 6
		fi
		count=$(($count + 1))
	    done
	fi
    fi

    # Do remake_initrd things (save old initrd)
    if [ -n "$remake_initrd" ]; then
	remake_initrd "${kernelver_array[0]}" "${arch_array[0]}"
	if [ "$?" -ne 0 ]; then
	    echo $"Problems with mkinitrd detected.  Automatically uninstalling this module."
	    sleep 2
	    do_uninstall "${kernelver_array[0]}" "${arch_array[0]}"
	    echo $""
	    echo $"DKMS: Install Failed (mkinitrd problems).  Module rolled back to built state."
	    exit 7
	fi
    fi
     
    echo $"" 
    echo $"DKMS: install Completed." 
}


function build_module()
{
    setup_kernels_arches "build"
    set_kernel_source_dir "${kernelver_array[0]}"

    # Check that the right arguments were passed
    if [ -z "$module" ] || [ -z "$module_version" ]; then
	echo $"" >>$std_err
	echo $"Error! Invalid number of parameters passed." >>$std_err
	echo $"Usage: build -m <module> -v <module-version>" >>$std_err
	exit 1
    fi

    # Check that source symlink works
    if ! [ -d "$dkms_tree/$module/$module_version/source" ]; then
	echo $"" >>$std_err
	echo $"Error! DKMS tree does not contain: $module-$module_version" >>$std_err
	echo $"Build cannot continue without the proper tree." >>$std_err
	exit 2
    fi

    # Check that the module has not already been built for this kernel
    if [ -d "$dkms_tree/$module/$module_version/${kernelver_array[0]}/${arch_array[0]}" ]; then
	echo $"" >>$std_err
	echo $"Error! This module/version has already been built on: ${kernelver_array[0]}" >>$std_err
	echo $"Directory: $dkms_tree/$module/$module_version/${kernelver_array[0]}/${arch_array[0]}" >>$std_err
	echo $"already exists.  Use the dkms remove function before trying to build again." >>$std_err
	exit 3
    fi
	
    # Read the conf file
    set_module_suffix "${kernelver_array[0]}"
    read_conf "${kernelver_array[0]}" "${arch_array[0]}"
    if [ "$?" -ne 0 ]; then
	echo $"" >>$std_err
	echo $"Error! Bad conf file." >>$std_err
	echo $"Your dkms.conf is not valid." >>$std_err
	exit 4
    fi

    # Error out if build_exclude is set
    if [ -n "$build_exclude" ]; then
	echo "" >>$std_err
	echo "Error!  The dkms.conf for this module includes a BUILD_EXCLUSIVE directive which" >>$std_err
	echo "does not match this kernel/arch.  This indicates that it should not be built." >>$std_err
	exit 9
    fi

    # Error out if source_tree is basically empty (binary-only dkms tarball w/ --force check)
    if [ `ls $dkms_tree/$module/$module_version/source | wc -l | awk {'print $1'}` -lt 2 ]; then
	echo "" >>$std_err
	echo $"Error! The directory $dkms_tree/$module/$module_version/source/" >>$std_err
	echo $"does not appear to have module source located within it.  Build halted." >>$std_err
	exit 8
    fi
    
    local should_prepare="$1"
    version_checker "${kernelver_array[0]}" "2.6.6"
    local rv=$?
    [ $rv -gt 9 ] && [ -d "$kernel_source_dir" ] && ! [ -h "$kernel_source_dir" ] && [ -z "$ksourcedir_fromcli" ] && should_prepare="no-prepare-kernel"

    # Prepare the kernel for the module build
    if [ "$should_prepare" != "no-prepare-kernel" ]; then
	prepare_kernel "${kernelver_array[0]}" "${arch_array[0]}"
    elif [ $rv -gt 9 ]; then
	echo $""
	echo $"Kernel preparation unnecessary for this kernel.  Skipping..."
    fi
    
    # Set up temporary build directory for build
    rm -rf "$dkms_tree/$module/$module_version/build"
    cp -rf "$dkms_tree/$module/$module_version/source/" "$dkms_tree/$module/$module_version/build"

    # Run the pre_build script
    if [ -n "$pre_build" ] && [ -x `echo "$dkms_tree/$module/$module_version/source/$pre_build" | sed 's/ .*//'` ]; then
	echo $"" 
	echo $"Running the pre_build script:" 
	$dkms_tree/$module/$module_version/source/$pre_build
    fi

    cd "$dkms_tree/$module/$module_version/build"
    echo $"" 
    echo $"Building module:" 

    # Apply any patches
    local index=0
    while [ $index -lt ${#patch_array[*]} ]; do
	if ! [ -e "$dkms_tree/$module/$module_version/build/patches/${patch_array[$index]}" ]; then
	    echo $"" >>$std_err
	    echo $"Error!  Patch ${patch_array[$index]} as specified in dkms.conf cannot be" >>$std_err
	    echo $"found in $dkms_tree/$module/$module_version/build/patches/." >>$std_err
	    exit 5
	fi
	invoke_command "patch -p1 < ./patches/${patch_array[$index]}" "applying patch ${patch_array[$index]}"
	if [ "$?" -ne 0 ]; then
	    echo $"" >>$std_err
	    echo $"Error! Application of patch ${patch_array[$index]} failed." >>$std_err
	    echo $"Check $dkms_tree/$module/$module_version/build/ for more information." >>$std_err
	    exit 6
	fi
	index=$(($index+1))
    done

    # Build
    invoke_command "$clean >/dev/null 2>&1" "cleaning build area" background
    echo $"DKMS make.log for $module-$module_version for kernel ${kernelver_array[0]} (${arch_array[0]})" >> "$dkms_tree/$module/$module_version/build/make.log"
    echo $"`date`" >> "$dkms_tree/$module/$module_version/build/make.log"
    local the_make_command=`echo $make_command | sed "s/^make/make KERNELRELEASE=${kernelver_array[0]}/"`
    invoke_command "$the_make_command >> $dkms_tree/$module/$module_version/build/make.log 2>&1" "$the_make_command" background

    # Make sure good return status
    if [ "$?" -ne 0 ]; then
	echo $"" >>$std_err
	echo $"Error! Bad return status for module build on kernel: ${kernelver_array[0]} (${arch_array[0]})" >>$std_err
	echo $"Consult the make.log in the build directory" >>$std_err
	echo $"$dkms_tree/$module/$module_version/build/ for more information." >>$std_err
	if [ `grep -ic "gcc: Command not found" "$dkms_tree/$module/$module_version/build/make.log"` -gt 0 ]; then
	    echo $"" >>$std_err
	    echo $"DO YOU HAVE gcc INSTALLED???" >>$std_err
	fi
	if [ `grep -ic "make: command not found" "$dkms_tree/$module/$module_version/build/make.log"` -gt 0 ]; then
	    echo $"" >>$std_err
	    echo $"DO YOU HAVE make INSTALLED???" >>$std_err
	fi
	exit 10
    fi	

    # Make sure all the modules built successfully
    local count=0
    while [ "$count" -lt "${#built_module_name[*]}" ]; do
	if ! [ -e "${built_module_location[$count]}${built_module_name[$count]}$module_suffix" ]; then
	    echo $"" >>$std_err
	    echo $"Error!  Build of ${built_module_name[$count]}$module_suffix failed for: ${kernelver_array[0]} (${arch_array[0]})" >>$std_err
	    echo $"Consult the make.log in the build directory" >>$std_err
	    echo $"$dkms_tree/$module/$module_version/build/ for more information." >>$std_err
	    exit 7
	fi
	count=$(($count+1))
    done
    cd -

    # Build success, so create DKMS structure for a built module
    mkdir -p "$dkms_tree/$module/$module_version/${kernelver_array[0]}/${arch_array[0]}/log"
    [ -n "$kernel_config" ] && cp -f "$kernel_config" "$dkms_tree/$module/$module_version/${kernelver_array[0]}/${arch_array[0]}/log/"  
    mv -f "$dkms_tree/$module/$module_version/build/make.log" "$dkms_tree/$module/$module_version/${kernelver_array[0]}/${arch_array[0]}/log/make.log" 2>/dev/null   

    # Save a copy of the new module
    mkdir "$dkms_tree/$module/$module_version/${kernelver_array[0]}/${arch_array[0]}/module" >/dev/null
    local count=0
    while [ "$count" -lt "${#built_module_name[*]}" ]; do
	[ "${strip[$count]}" != "no" ] && strip -g "$dkms_tree/$module/$module_version/build/${built_module_location[$count]}${built_module_name[$count]}$module_suffix"
	cp -f "$dkms_tree/$module/$module_version/build/${built_module_location[$count]}${built_module_name[$count]}$module_suffix" "$dkms_tree/$module/$module_version/${kernelver_array[0]}/${arch_array[0]}/module/${dest_module_name[$count]}$module_suffix" >/dev/null
	count=$(($count+1))
    done

    # Run the post_build script
    if [ -n "$post_build" ] && [ -x `echo "$dkms_tree/$module/$module_version/source/$post_build" | sed 's/ .*//'` ]; then
	echo $"" 
	echo $"Running the post_build script:" 
	$dkms_tree/$module/$module_version/source/$post_build
    fi
    
    # Run the clean commands
    cd "$dkms_tree/$module/$module_version/build"
    invoke_command "$clean >/dev/null 2>&1" "cleaning build area" background
    cd -
    if [ "$should_prepare" != "no-prepare-kernel" ] && [ -z "$no_clean_kernel" ]; then
	cd "$kernel_source_dir"
	[ -z "$kerneldoth_contents" ] && invoke_command "make mrproper >/dev/null 2>&1" "cleaning kernel tree (make mrproper)" background
	[ -n "$config_contents" ] && echo "$config_contents" > .config
	[ -n "$kerneldoth_contents" ] && echo "$kerneldoth_contents" > /boot/kernel.h
	cd -
    fi

    # Clean the build directory
    rm -rf "$dkms_tree/$module/$module_version/build/*"

    echo $"" 
    echo $"DKMS: build Completed." 
}

function do_uninstall()
{
    # $1 = kernel version
    # $2 = arch

    echo $"" 
    echo $"-------- Uninstall Beginning --------" 
    echo $"Module:  $module"  
    echo $"Version: $module_version" 
    echo $"Kernel:  $1 ($2)" 
    echo $"-------------------------------------" 

    set_module_suffix "$1"

    # If kernel-<kernelver> symlink points to this module, check for original_module and put it back
    local was_active=""
    readlink "$dkms_tree/$module/kernel-$1-$2"
    local kernel_symlink="$read_link"
    if [ "$kernel_symlink" == "$module_version/$1/$2" ]; then
	was_active="true"
	echo $"" 
	echo $"Status: Before uninstall, this module version was ACTIVE on this kernel."
	count=0
	while [ "$count" -lt "${#built_module_name[*]}" ]; do
	    echo $""
	    echo $"${dest_module_name[$count]}$module_suffix:"
	    echo $" - Uninstallation"
	    echo $"   - Deleting from: $install_tree/$1${dest_module_location[$count]}/" 
	    rm -f "$install_tree/$1${dest_module_location[$count]}/${dest_module_name[$count]}$module_suffix"
	    echo $" - Original module"
	    if [ -e "$dkms_tree/$module/original_module/$1/$2/${dest_module_name[$count]}$module_suffix" ]; then
		echo $"   - Archived original module found in the DKMS tree" 
		echo $"   - Moving it to: $install_tree/$1${dest_module_location[$count]}/" 
		mv -f "$dkms_tree/$module/original_module/$1/$2/${dest_module_name[$count]}$module_suffix" "$install_tree/$1${dest_module_location[$count]}/" 2>/dev/null
	    else
		echo $"   - No original module was found for this module on this kernel." 
		echo $"   - Use the dkms install command to reinstall any previous module version." 
		
	        # Remove modules_conf entries from /etc/modules.conf if remake_initrd is set or if this is last instance removed
		[ -n "$remake_initrd" ] || [ `$0 status -m $module -v $module_version | grep -c "installed"` -eq 1 ] && echo $"" && moduleconfig_remove "${kernelver_array[0]}"
	    fi
	    count=$(($count+1))
	done
	rm -f "$dkms_tree/$module/kernel-$1-$2"
    else
	echo $"" 
	echo $"Status: This module version was INACTIVE for this kernel." 
    fi

    # Run the post_remove script
    if [ -n "$post_remove" ] && [ -x `echo "$dkms_tree/$module/$module_version/source/$post_remove" | sed 's/ .*//'` ]; then
	echo $"" 
	echo $"Running the post_remove script:" 
	$dkms_tree/$module/$module_version/source/$post_remove
    fi
    
    # Do remake_initrd things (remake initrd)
    if [ -n "$remake_initrd" ] && [ -n "$was_active" ]; then
	remake_initrd "$1" "$2"
	if [ "$?" -ne 0 ]; then
	    echo $""
	    echo $"WARNING! WARNING! WARNING!"
	    echo $"There was a problem remaking your initrd.  You must manually remake it"
	    echo $"before booting into this kernel."
	    echo $""
	fi
    fi

    # Delete the original_module if nothing for this kernel is installed anymore
    if [ -n "$was_active" ] && [ -d "$dkms_tree/$module/original_module/$1/$2" ] && ! [ -d "$dkms_tree/$module/original_module/$1/$2/collisions" ]; then
	echo $"" 
	echo $"Removing original_module from DKMS tree for kernel $1 ($2)" 
	rm -rf "$dkms_tree/$module/original_module/$1/$2" 2>/dev/null
	[ -z "`find $dkms_tree/$module/original_module/$1/* -maxdepth 0 -type d 2>/dev/null`" ] && rm -rf "$dkms_tree/$module/original_module/$1"
    elif [ -n "$was_active" ] && [ -d "$dkms_tree/$module/original_module/$1/$2/collisions" ]; then
	echo $""
	echo $"Keeping directory $dkms_tree/$module/original_module/$1/$2/collisions/"
	echo $"for your reference purposes.  Your kernel originally contained multiple"
	echo $"same-named modules and this directory is now where these are located."
    fi
    [ -z "`find $dkms_tree/$module/original_module/* -maxdepth 0 -type d 2>/dev/null`" ] && rm -rf "$dkms_tree/$module/original_module"

    # Re-add entries to modules.conf if this module/version is still installed on another kernel
    # But only do this if it was just ACTIVE on the kernel we just uninstalled from
    [ -n "$was_active" ] && [ -n "$remake_initrd" ] && [ `$0 status -m $module -v $module_version | grep -c "installed"` -gt 0 ] && moduleconfig_add "$1"
    
    echo $"" 
    echo $"DKMS: uninstall Completed." 
}

function uninstall_module ()
{
    setup_kernels_arches "uninstall"

    # Check that the right arguments were passed
    if [ -z "$module" ] || [ -z "$module_version" ]; then
	echo $"" >>$std_err
	echo $"Error! Invalid number of parameters passed." >>$std_err
	echo $"Usage: uninstall -m <module> -v <module-version>" >>$std_err
	echo $"   or: uninstall -m <module> -v <module-version> -k <kernel-version>" >>$std_err
	exit 1
    fi

    # Check that $module is in the dkms tree
    if ! [ -d "$dkms_tree/$module" ]; then
	echo $"" >>$std_err
	echo $"Error! There are no instances of module: $module" >>$std_err
	echo $"located in the DKMS tree." >>$std_err
	exit 2
    fi

    # Make sure that its installed in the first place
    if ! [ -d "$dkms_tree/$module/$module_version" ]; then
	echo $"" >>$std_err
	echo $"Error! The module/version combo: $module-$module_version" >>$std_err
	echo $"is not located in the DKMS tree." >>$std_err
	exit 3
    fi

    # Read the conf file
    read_conf "${kernelver_array[0]}" "${arch_array[0]}"
    if [ "$?" -ne 0 ]; then
	echo $"" >>$std_err
	echo $"Error! Bad conf file." >>$std_err
	echo $"Your dkms.conf is not valid." >>$std_err
	exit 4
    fi

    # Only do stuff if module/module version is currently installed
    readlink "$dkms_tree/$module/kernel-${kernelver_array[0]}-${arch_array[0]}"
    local kernel_symlink="$read_link"
    if [ "$kernel_symlink" == "$module_version/${kernelver_array[0]}/${arch_array[0]}" ]; then
	do_uninstall "${kernelver_array[0]}" "${arch_array[0]}"
    else
	echo $"" >>$std_err
	echo $"Error! The module $module $module_version is not currently installed." >>$std_err
	echo $"This module is not currently ACTIVE for kernel ${kernelver_array[0]} (${arch_array[0]})." >>$std_err
	exit 5
    fi
}

function remove_module ()
{
    # Check that the right arguments were passed (must be done before setup_kernels_arches)
    if [ -z "$module" ] || [ -z "$module_version" ] || $([ -z "${kernelver_array[0]}" ] && [ -z "$all" ]); then
	echo $"" >>$std_err
	echo $"Error! Invalid number of parameters passed." >>$std_err
	echo $"Usage: remove -m <module> -v <module-version> --all" >>$std_err
	echo $"   or: remove -m <module> -v <module-version> -k <kernel-version>" >>$std_err
	exit 1
    fi

    setup_kernels_arches "remove"

    # Check that $module is in the dkms tree
    if ! [ -d "$dkms_tree/$module/$module_version" ]; then
	echo $"" >>$std_err
	echo $"Error! There are no instances of module: $module" >>$std_err
	echo $"$module_version located in the DKMS tree." >>$std_err
	exit 3
    fi

    local i=0
    while [ $i -lt ${#kernelver_array[*]} ]; do

        # make sure its there first before removing
	if ! [ -d "$dkms_tree/$module/$module_version/${kernelver_array[$i]}/${arch_array[$i]}" ]; then
	    echo $"" >>$std_err
	    echo $"Error! There is no instance of $module $module_version" >>$std_err
	    echo $"for kernel ${kernelver_array[$i]} (${arch_array[$i]}) located in the DKMS tree." >>$std_err
	    exit 4
	fi
	
        # Do --rpm_safe_upgrade check (exit out and don't do remove if inter-release RPM upgrade scenario occurs)
	if [ -n "$rpm_safe_upgrade" ]; then
	    local pppid=`cat /proc/$PPID/status | grep PPid: | awk {'print $2'}`
	    local time_stamp=`ps -o lstart --no-headers -p $pppid 2>/dev/null`
	    for lock_file in `ls $tmp_location/dkms_rpm_safe_upgrade_lock.$pppid.* 2>/dev/null`; do
		lock_head=`head -1 $lock_file 2>/dev/null`
		lock_tail=`tail -1 $lock_file 2>/dev/null`
		if [ "$lock_head" == "$module-$module_version" ] && [ "$lock_tail" == "$time_stamp" ] && [ -n "$time_stamp" ]; then
		    echo $""
		    echo $"DKMS: Remove cancelled because --rpm_safe_upgrade scenario detected."
		    rm -f $lock_file
		    exit 0
		fi
	    done
	fi
	
        # Read the conf file
	read_conf "${kernelver_array[$i]}" "${arch_array[$i]}"
	if [ "$?" -ne 0 ]; then
	    echo $"" >>$std_err
	    echo $"Error! Bad conf file." >>$std_err
	    echo $"File: $dkms_tree/$module/$module_version/source/dkms.conf does not represent" >>$std_err
	    echo $"a valid dkms.conf file." >>$std_err
	    exit 5
	fi
	
	do_uninstall "${kernelver_array[$i]}" "${arch_array[$i]}"
	    
        # Delete the $kernel_version/$arch_used part of the tree
	rm -rf "$dkms_tree/$module/$module_version/${kernelver_array[$i]}/${arch_array[$i]}"
	[ -z "`find $dkms_tree/$module/$module_version/${kernelver_array[$i]}/* -maxdepth 0 -type d 2>/dev/null`" ] && rm -rf "$dkms_tree/$module/$module_version/${kernelver_array[$i]}"

	i=$(($i + 1))
    done
    
    # Delete the $module_version part of the tree if no other $module_version/$kernel_version dirs exist
    if [ -z "`find $dkms_tree/$module/$module_version/* -maxdepth 0 -type d 2>/dev/null | grep -v build$ | grep -v tarball$ | grep -v driver_disk$ | grep -v rpm$`"  ]; then
	echo $"" 
	echo $"------------------------------" 
	echo $"Deleting module version: $module_version" 
	echo $"completely from the DKMS tree." 
	echo $"------------------------------" 
	rm -rf "$dkms_tree/$module/$module_version"
	echo $"Done."
    fi

    # Get rid of any remnant directories if necessary
    if [ `ls "$dkms_tree/$module" | wc -w | awk '{print $1}'` -eq 0 ]; then
	rm -rf "$dkms_tree/$module" 2>/dev/null
       
	# Its now safe to completely remove references in /etc/sysconfig/kernel for SuSE
	etc_sysconfig_kernel_modify "delete"
    fi
}

do_status () 
{
    local mod="$1"; shift
    local ver="$1"; shift
    local kern="$1"; shift
    local arch="$1"; shift
    local tree_depth="$1"; shift
    
    local next
    local working_dir
    [ $tree_depth -eq 0 ] && next="mod"  && working_dir="$dkms_tree"
    [ $tree_depth -eq 1 ] && next="ver"  && working_dir="$dkms_tree/$mod"
    [ $tree_depth -eq 2 ] && next="kern" && working_dir="$dkms_tree/$mod/$ver"
    [ $tree_depth -eq 3 ] && next="arch" && working_dir="$dkms_tree/$mod/$ver/$kern"
    [ $tree_depth -eq 4 ] && next="done" && working_dir="$dkms_tree/$mod/$ver/$kern/$arch"
    
    if [ -n "${!next}" ] && [ "$next" != "done" ]; then
	do_status "$mod" "$ver" "$kern" "$arch" "$(($tree_depth + 1))"
    elif [ "$next" != "done" ]; then
	local keep_traversing="no"
	for directory in `find "$working_dir" -type d -maxdepth 1 -mindepth 1 2>/dev/null`; do
	    local next_value=`echo $directory | sed "s#$working_dir/##"`
	    if [ `echo "build original_module tarball driver_disk rpm" | grep -c "$next_value\b"` -eq 0 ]; then
		keep_traversing="yes"
		[ "$next" == "mod" ]  && mod=$next_value
		[ "$next" == "ver" ]  && ver=$next_value
		[ "$next" == "kern" ] && kern=$next_value	
		[ "$next" == "arch" ] && arch=$next_value
		do_status "$mod" "$ver" "$kern" "$arch" "$(($tree_depth + 1))" 
	    fi
	done
    fi
    
    if [ "$keep_traversing" == "no" ] && [ $tree_depth -eq 2 ] && [ -z "$arch" ] || [ "$next" == "done" ]; then
	local state="added" && stat_display="$mod, $ver:"
	[ -d "$working_dir/module" ] && state="built" && stat_display="$mod, $ver, $kern, $arch:"
	if [ -h "$dkms_tree/$mod/kernel-$kern-$arch" ]; then
	    readlink "$dkms_tree/$mod/kernel-$kern-$arch"
	    [ "$read_link" == "$ver/$kern/$arch" ] && state="installed"
	fi
	
	if [ "$state" == "built" ] || [ "$state" == "installed" ]; then
	    set_module_suffix "$kern"
	    local extra_status=""
	    conf="$dkms_tree/$mod/$ver/source/dkms.conf"
	    read_conf "$kern" "$arch" "$conf"
	    [ -d "$dkms_tree/$mod/original_module/$kern/$arch" ] && extra_status="(original_module exists)"
	    local count=0
	    while [ "$count" -lt "${#dest_module_name[*]}" ]; do
		tree_mod="$dkms_tree/$mod/$ver/$kern/$arch/module/${dest_module_name[$count]}$module_suffix"
		if ! [ -e "$tree_mod" ]; then
		    extra_status="$extra_status (WARNING! Missing some built modules!)"	
		elif [ "$state" == "installed" ] && ! `diff "$tree_mod" "$install_tree/$kern${dest_module_location[$count]}/${dest_module_name[$count]}$module_suffix" >/dev/null 2>&1`; then
		    extra_status="$extra_status (WARNING! Diff between built and installed module!)"
		fi
		count=$(($count+1))
	    done
	fi

	[ -d "$working_dir" ] && echo "$stat_display $state $extra_status"	
    fi
}

show_status () 
{
    setup_kernels_arches "status"

    local j=0
    if [ ${#kernelver_array[*]} -eq 0 ]; then
	do_status "$module" "$module_version" "${kernelver_array[0]}" "${arch_array[0]}" 0
    else
	while [ $j -lt ${#kernelver_array[*]} ]; do
	    do_status "$module" "$module_version" "${kernelver_array[$j]}" "${arch_array[$j]}" 0
	    j=$(($j + 1))
	done
    fi
}

make_driver_disk ()
{
    setup_kernels_arches "mkdriverdisk"

    # Check that the right arguments were passed
    if [ -z "$module" ] || [ -z "$module_version" ] || [ -z "$distro" ] || [ -z "${kernelver_array[0]}" ]; then
	echo $"" >>$std_err
	echo $"Error! Invalid number of parameters passed." >>$std_err
	echo $"Usage: mkdriverdisk -d <distro> -m <module> -v <module-version> -k <kernelver>" >>$std_err
	exit 1
    fi   

    # Check that source symlink works
    if ! [ -d "$dkms_tree/$module/$module_version/source" ]; then
	echo $"" >>$std_err
	echo $"Error! DKMS tree does not contain: $module-$module_version" >>$std_err
	echo $"Build cannot continue without the proper tree." >>$std_err
	exit 2
    fi

    # Confirm that distro is supported
    if [ "$distro" != "redhat" ] && [ "$distro" != "redhat1" ] && [ "$distro" != "redhat2" ] && [ "$distro" != "suse" ] && [ "$distro" != "UnitedLinux" ]; then
	echo $"" >>$std_err
	echo $"Error! Invalid distro argument. Currently, the distros" >>$std_err
	echo $"supported are: redhat, redhat1, redhat2, suse, UnitedLinux" >>$std_err 
	exit 3
    fi

    # Read the conf file
    read_conf "${kernelver_array[0]}" "${arch_array[0]}"
    if [ "$?" -ne 0 ]; then
	echo $"" >>$std_err
	echo $"Error! Bad conf file." >>$std_err
	echo $"Your dkms.conf is not valid." >>$std_err
	exit 4
    fi

    if [ `echo $distro | grep -c "redhat"` -gt 0 ]; then
	make_redhat_driver_disk
    else
	make_suse_driver_disk
    fi
}

make_redhat_driver_disk() 
{
    # kludge to allow redhat1 driver disks with BOOT kernel modules (arch i386)
    if [ "$distro" == "redhat1" ] && [ "$multi_arch" == "true" ]; then
	local i=0
	local redhat1_okay="true"
	local other_arch=""
	while [ $i -lt ${#kernelver_array[*]} ]; do
		if [ "${arch_array[$i]}" != "i386" ] && [ "$other_arch" != "${arch_array[$i]}" ] && [ -n "$other_arch" ]; then
			redhat1_okay="false"
		elif [ "${arch_array[$i]}" != "i386" ] && [ "$other_arch" != "${arch_array[$i]}" ] && [ -z "$other_arch" ]; then
			other_arch="${arch_array[$i]}" 
		fi
		i=$(($i+1))
	done
	if [ "$redhat1_okay" == "false" ]; then
		echo $"" >>$std_err
		echo $"Error! You have specified a Red Hat version 1 driver disk, but have also"  >>$std_err
		echo $"specified multiple architectures.  Version 1 does not support this." >>$std_err
		echo $"Use 'redhat2' instead (only OSes >= RHEL3, FC1 support version 2)." >>$std_err
		exit 3
	fi
    fi

    if [ "$distro" == "redhat2" ] || [ "$multi_arch" == "true" ] && [ -z "$redhat1_okay" ]; then
	echo $"Creating Red Hat v2 driver disk (arch support)."
	echo $""
	local rhdd_filename="rhdd"
    else
	echo $"Creating Red Hat v1 driver disk."
	echo $""
	local rhdd_filename="rhdd-6.1"
    fi

    temp_dir_name=`mktemp -d $tmp_location/dkms.XXXXXX`

    local i=0
    while [ $i -lt ${#kernelver_array[*]} ]; do
	set_module_suffix "${kernelver_array[$i]}"
	local count=0

 	local dd_prefix="${kernelver_array[$i]}"
	[ "$distro" == "redhat2" ] && dd_prefix="${kernelver_array[$i]}/${arch_array[$i]}"
	[ "$multi_arch" == "true" ] && [ -z "$redhat1_okay" ] && dd_prefix="${kernelver_array[$i]}/${arch_array[$i]}"
	
	while [ "$count" -lt "${#dest_module_name[*]}" ]; do
	    if ! [ -e "$dkms_tree/$module/$module_version/${kernelver_array[$i]}/${arch_array[$i]}/module/${dest_module_name[$count]}$module_suffix" ]; then
		echo $"" >>$std_err
		echo $"Error! Cannot find module ${dest_module_name[$count]}$module_suffix for kernel ${kernelver_array[$i]} (${arch_array[$i]})." >>$std_err
		echo $"Module/version must be in built state before making a driver disk." >>$std_err
		rm -rf $temp_dir_name
		exit 5
	    fi
	    if [ -z "$kernel_version_list" ]; then
		kernel_version_list="kernel${kernelver_array[$i]}-${arch_array[$i]}"
	    else
		kernel_version_list="$kernel_version_list-kernel${kernelver_array[$i]}-${arch_array[$i]}"
	    fi
	    mkdir -p $temp_dir_name/$dd_prefix
	    echo "Marking ${kernelver_array[$i]}/${arch_array[$i]}/module/${dest_module_name[$count]}$module_suffix..."
	    cp "$dkms_tree/$module/$module_version/${kernelver_array[$i]}/${arch_array[$i]}/module/${dest_module_name[$count]}$module_suffix" "$temp_dir_name/$dd_prefix/"
	    
	    modules_cgz_list="$dd_prefix/${dest_module_name[$count]}$module_suffix\n${modules_cgz_list}"
	    count=$(($count+1))
	done
	
	i=$(($i + 1))
    done

    # Create directory and necessary files
    mkdir -p "$dkms_tree/$module/$module_version/driver_disk"
   
    # Copy files for the driver disk (or warn if not present)
    local files_for_driverdisk="modinfo disk-info modules.dep pcitable"
    local files_into_driverdisk="modules.cgz $rhdd_filename"
    for file in $files_for_driverdisk; do
	if ! [ -e "$dkms_tree/$module/$module_version/source/redhat_driver_disk/$file" ]; then
	    echo $"Warning! File: $file not found in $dkms_tree/$module/$module_version/source/redhat_driver_disk/" >>$std_err
	else
	    files_into_driverdisk="$file $files_into_driverdisk"
	    cp -f "$dkms_tree/$module/$module_version/source/redhat_driver_disk/$file" "$dkms_tree/$module/$module_version/driver_disk/" 2>/dev/null
	fi
    done
    echo "$module-$module_version driver disk" > "$dkms_tree/$module/$module_version/driver_disk/$rhdd_filename"

    # Make sure the kernel_version_list is not too long
    if [ `echo $kernel_version_list | wc -m | awk {'print $1'}` -gt 200 ]; then
	kernel_version_list="manykernels"
    fi

    # Create dos disk image
    local image_name="$module-$module_version-$kernel_version_list-dd.img"  
    echo $""
    echo $"Creating driver disk:"
    cd $temp_dir_name
    invoke_command "echo -e '$modules_cgz_list' | cpio -oH crc 2>/dev/null | gzip -9 > ./modules.cgz" "compressing modules.cgz" background
    cp -f ./modules.cgz "$dkms_tree/$module/$module_version/driver_disk/"
    cd -
    rm -rf $temp_dir_name
    cd "$dkms_tree/$module/$module_version/driver_disk/"
    rm -f $image_name
    invoke_command "dd if=/dev/zero of="./$image_name" bs=72k count=20 >/dev/null 2>&1" "making a blank floppy image" background
    invoke_command "mkdosfs ./$image_name >/dev/null 2>&1" "mkdosfs" background
    mkdir ./mnt
    invoke_command "mount -o loop -t vfat $image_name ./mnt >/dev/null 2>&1" "loopback mounting disk image"
    for file in $files_into_driverdisk; do
	invoke_command "cp -f ./$file ./mnt/" "  copying $file to disk image"
    done
    invoke_command "umount ./mnt" "unmounting disk image"
    rm -rf ./mnt
    cd -
    echo $""
    echo $"Disk image location: $dkms_tree/$module/$module_version/driver_disk/$image_name"
    echo $""
    echo $"DKMS: mkdriverdisk Completed."
}

make_suse_driver_disk()
{
    if [ -z "$release" ]; then
	echo $"" >>$std_err
	echo $"Error! Invalid number of parameters passed for suse/UnitedLinux driver disk." >>$std_err
	echo $"Usage: mkdriverdisk -d <distro> -m <module> -v <module-version> -k <kernelver>" >>$std_err
	echo $"                    -r <release-number>" >>$std_err
	exit 3
    fi

    temp_dir_name=`mktemp -d $tmp_location/dkms.XXXXXX`

    local i=0
    while [ $i -lt ${#kernelver_array[*]} ]; do
	set_module_suffix "${kernelver_array[$i]}"
	local count=0
	while [ "$count" -lt "${#dest_module_name[*]}" ]; do
	    if ! [ -e "$dkms_tree/$module/$module_version/${kernelver_array[$i]}/${arch_array[$i]}/module/${dest_module_name[$count]}$module_suffix" ]; then
		echo $"" >>$std_err
		echo $"Error! Cannot find module ${dest_module_name[$count]}$module_suffix for kernel ${kernelver_array[$i]} (${arch_array[$i]})." >>$std_err
		echo $"Module/version must be in built state before making a driver disk." >>$std_err
		rm -rf $temp_dir_name
		exit 5
	    fi
	    [ `echo ${arch_array[$i]} | grep -c i.86` -gt 0 ] && suse_arch="i386" || suse_arch=${arch_array[$i]}
	    echo "Marking ${kernelver_array[$i]}/${arch_array[$i]}/modules/${dest_module_name[$count]}$module_suffix..."
	    mkdir -p "$temp_dir_name/$suse_arch-$release/install/lib/modules/${kernelver_array[$i]}${dest_module_location[$count]}"
	    cp "$dkms_tree/$module/$module_version/${kernelver_array[$i]}/${arch_array[$i]}/module/${dest_module_name[$count]}$module_suffix" "$temp_dir_name/$suse_arch-$release/install/lib/modules/${kernelver_array[$i]}${dest_module_location[$count]}/"
	    if [ `echo ${kernelver_array[$i]} | grep -c "\-default$"` -gt 0 ]; then
		mkdir -p "$temp_dir_name/$suse_arch-$release/modules/"
		cp "$dkms_tree/$module/$module_version/${kernelver_array[$i]}/${arch_array[$i]}/module/${dest_module_name[$count]}$module_suffix" "$temp_dir_name/$suse_arch-$release/modules/"
	    fi
	    count=$(($count+1))
	done
	i=$(($i + 1))
    done

    mkdir -p "$dkms_tree/$module/$module_version/driver_disk"
    local image_name="$module-$module_version-$distro-$release-dd.img"  
    echo $""
    echo $"Creating driver disk:"

    for arch_release in `find $temp_dir_name -type d -maxdepth 1 -mindepth 1 | sed "s#$temp_dir_name\/##"`; do
	cd $temp_dir_name/$arch_release/install/
	invoke_command "tar cvzf update.tar.gz lib/ >/dev/null 2>&1" "making update.tar.gz for $arch_release" background
	cd -
    done

    cd "$dkms_tree/$module/$module_version/driver_disk/"
    rm -f $image_name
    invoke_command "dd if=/dev/zero of="./$image_name" bs=72k count=20 >/dev/null 2>&1" "making a blank floppy image" background
    invoke_command "mke2fs ./$image_name >/dev/null 2>&1" "mke2fs" background
    mkdir ./mnt 2>/dev/null
    invoke_command "mount -o loop -t ext2 $image_name ./mnt >/dev/null 2>&1" "loopback mounting disk image"
    mkdir -p ./mnt/linux/$distro
    for arch_release in `find $temp_dir_name -type d -maxdepth 1 -mindepth 1 | sed "s#$temp_dir_name\/##"`; do
	mkdir -p ./mnt/linux/$distro/$arch_release/install
	mkdir -p ./mnt/linux/$distro/$arch_release/modules
	echo $"  copying update.tar.gz for $arch_release to disk image..."
	cp -f $temp_dir_name/$arch_release/install/update.tar.gz ./mnt/linux/$distro/$arch_release/install/
	if [ -d $temp_dir_name/$arch_release/modules/ ]; then
	    echo $"  copying kernel modules for installation kernel to disk image..."
	    cp -f $temp_dir_name/$arch_release/modules/* ./mnt/linux/$distro/$arch_release/modules/ 2>/dev/null
	else
	    echo $"  warning! no kernel modules found for -default kernel."
	fi
    done
    invoke_command "umount ./mnt" "unmounting disk image"
    rm -rf ./mnt
    rm -rf $temp_dir_name
    cd -
    echo $""
    echo $"Disk image location: $dkms_tree/$module/$module_version/driver_disk/$image_name"
    echo $""
    echo $"DKMS: mkdriverdisk Completed."
}

make_tarball()
{
    setup_kernels_arches "mktarball"

    # Error if $module_version is set but $module is not
    if [ -z "$module" ] || [ -z "$module_version" ]; then
	echo $"" >>$std_err
	echo $"Error! Invalid number of parameters passed." >>$std_err
	echo $"Usage: mktarball -m <module> -v <module-version>" >>$std_err
	exit 1	
    fi

    # Check that source symlink works
    if ! [ -d "$dkms_tree/$module/$module_version/source" ]; then
	echo $"" >>$std_err
	echo $"Error! DKMS tree does not contain: $module-$module_version" >>$std_err
	echo $"Build cannot continue without the proper tree." >>$std_err
	exit 2
    fi

    # Make sure that its installed in the first place
    if ! [ -d "$dkms_tree/$module/$module_version" ]; then
	echo $"" >>$std_err
	echo $"Error! The module/version combo: $module-$module_version" >>$std_err
	echo $"is not located in the DKMS tree." >>$std_err
	exit 3
    fi

    # Error out if archive_location is set and contains a "/" in it
    if [ `echo "$archive_location" | grep -c "/"` -gt 0 ]; then
	echo $"" >>$std_err
	echo $"Error!  The name you have specified for your tarball contains a '/'." >>$std_err
	echo $"You may only specify a simple filename with no preceding path."
	exit 7
    fi

    # Error out if binaries-only is set and source-only is set
    if [ -n "$binaries_only" ] && [ -n "$source_only" ]; then
	echo $"" >>$std_err
	echo $"Error!  You have specified both --binaries-only and --source-only." >>$std_err
	echo $"You cannot do this." >>$std_err
	exit 8
    fi

    # Read the conf file
    read_conf "${kernelver_array[0]}" "${arch_array[0]}"
    if [ "$?" -ne 0 ]; then
	echo $"" >>$std_err
	echo $"Error! Bad conf file." >>$std_err
	echo $"Your dkms.conf is not valid." >>$std_err
	exit 5
    fi
    
    temp_dir_name=`mktemp -d $tmp_location/dkms.XXXXXX`
    mkdir -p $temp_dir_name/dkms_main_tree

    if [ -n "$source_only" ]; then
	kernel_version_list="source-only"
    else
	local i=0
	while [ $i -lt ${#kernelver_array[*]} ]; do
	    
	    if ! [ -d "$dkms_tree/$module/$module_version/${kernelver_array[$i]}/${arch_array[$i]}" ]; then
		echo $"" >>$std_err
		echo $"Error! No modules built for ${kernelver_array[$i]} (${arch_array[$i]})." >>$std_err
		echo $"Modules must already be in the built state before using mktarball." >>$std_err
		rm -rf "$temp_dir_name" 2>/dev/null
		exit 6	
	    fi

	    set_module_suffix "${kernelver_array[$i]}"
	    
	    echo "Marking modules for ${kernelver_array[$i]} (${arch_array[$i]}) for archiving..."
	    if [ -z "$kernel_version_list" ]; then
		kernel_version_list="kernel${kernelver_array[$i]}-${arch_array[$i]}"
	    else
		kernel_version_list="${kernel_version_list}-kernel${kernelver_array[$i]}-${arch_array[$i]}"
	    fi
	    mkdir -p "$temp_dir_name/dkms_main_tree/${kernelver_array[$i]}/${arch_array[$i]}"
	    cp -rf "$dkms_tree/$module/$module_version/${kernelver_array[$i]}/${arch_array[$i]}" "$temp_dir_name/dkms_main_tree/${kernelver_array[$i]}"
	    
	    i=$(($i + 1))
	done
    fi
	
    # Store the dkms_dbversion in the tarball
    cp -f "$dkms_tree/dkms_dbversion" "$temp_dir_name/dkms_main_tree/"

    # Copy the source_tree or make special binaries-only structure
    if [ -z "$binaries_only" ]; then
	echo $""
	echo $"Marking $source_tree/$module-$module_version for archiving..."
	mkdir -p $temp_dir_name/dkms_source_tree
	cp -rf $source_tree/$module-$module_version/* $temp_dir_name/dkms_source_tree
    else
	echo $""
	echo $"Binaries only specified.  Creating special tarball structure to accomodate."
	mkdir $temp_dir_name/dkms_binaries_only
	echo "$module" > $temp_dir_name/dkms_binaries_only/PACKAGE_NAME
	echo "$module_version" > $temp_dir_name/dkms_binaries_only/PACKAGE_VERSION
	[ -z "$conf" ] && conf="$dkms_tree/$module/$module_version/source/dkms.conf"
	cp -f $conf $temp_dir_name/dkms_binaries_only/ 2>/dev/null
    fi

    # Make the tarball
    cd $temp_dir_name
    if [ `echo $kernel_version_list | wc -m | awk {'print $1'}` -gt 200 ]; then
	kernel_version_list="manykernels"
    fi
    local tarball_name="$module-$module_version-$kernel_version_list.dkms.tar.gz"
    [ -n "$archive_location" ] && tarball_name="$archive_location"
    tar -czf $temp_dir_name/$tarball_name ./* 2>/dev/null
    cd -
    if [ "$?" -eq 0 ]; then
	mkdir -p $dkms_tree/$module/$module_version/tarball
	mv -f $temp_dir_name/$tarball_name $dkms_tree/$module/$module_version/tarball/
	echo $""
	echo $"Tarball location: $dkms_tree/$module/$module_version/tarball/$tarball_name"
	echo $""
	echo $"DKMS: mktarball Completed."
	rm -rf $temp_dir_name
    else
	echo $"" >>$std_err
	echo $"Error! Failed to make tarball." >>$std_err
	rm -rf $temp_dir_name
	exit 6
    fi
}

load_tarball()
{
    setup_kernels_arches "mktarball"

    # Error out of --archive was not set with the tarball location
    if [ -z "$archive_location" ]; then
	echo $"" >>$std_err
	echo $"Error! Invalid number of parameters passed." >>$std_err
	echo $"Usage: ldtarball --archive=<tarball-location>" >>$std_err
	exit 1	
    fi

    # Error out if $archive_location does not exist
    if ! [ -e "$archive_location" ]; then
	echo $"" >>$std_err
	echo $"Error! Cannot locate $archive_location." >>$std_err
	echo $"File does not exist." >>$std_err
	exit 2
    fi

    # Figure out what kind of archive it is (tar.gz, tar, tar.bz, etc)
    local tar_options=""
    if `gzip -t $archive_location 2>/dev/null`; then
	tar_options="${tar_options}z"
    fi
    if `bzip2 -t $archive_location 2>/dev/null`; then
	tar_options="${tar_options}j"
    fi

    # Untar it into $tmp_location
    local temp_dir_name=`mktemp -d $tmp_location/dkms.XXXXXX`
    tar -${tar_options}xf $archive_location -C $temp_dir_name 

    # Check that dkms_dbversion is not a future version
    db_from_tarball="`cat $temp_dir_name/dkms_main_tree/dkms_dbversion 2>/dev/null`"
    db_from_dkms="`cat $dkms_tree/dkms_dbversion 2>/dev/null`"
    if [ -n "$db_from_tarball" ] && [ -n "$db_from_dkms" ]; then
	version_checker "$db_from_tarball" "$db_from_dkms"
	if [ "$?" -eq 11 ]; then
	    echo $"" >>$std_err
	    echo $"Error! The tarball you are trying to load indicates it is database version" >>$std_err
	    echo $"$db_from_tarball.  This version of DKMS only supports $db_from_dkms or lower.">>$std_err
	    rm -rf $temp_dir_name
	    exit 9
	fi
    fi

    # Make sure its a sane tarball
    PACKAGE_NAME=""
    PACKAGE_VERSION=""
    local is_from_mktarball=""
    local is_binaries_only=""
    local is_not_arch_aware=""
    if ! [ -d "$temp_dir_name/dkms_main_tree" ]; then
	conf=`find $temp_dir_name/ -name dkms.conf 2>/dev/null | head -1`
	if [ -z "$conf" ]; then
	    echo $"" >>$std_err
	    echo $"Error! Tarball does not appear to be a correctly formed" >>$std_err
	    echo $"DKMS archive. No dkms.conf found within it." >>$std_err
	    rm -rf $temp_dir_name
	    exit 3
	fi
	read_conf "${kernelver_array[0]}" "${arch_array[0]}" "$conf"
	if [ "$?" -ne 0 ]; then
	    echo $"" >>$std_err
	    echo $"Error! Bad conf file." >>$std_err
	    echo $"File: $conf does not represent a valid dkms.conf file" >>$std_err
	    rm -rf $temp_dir_name
	    exit 4
	fi
	tarball_source_tree_name=`echo $conf | sed "s#$temp_dir_name\/##" | sed 's/dkms.conf//' | sed 's/\/$//'`
    elif ! [ -d "$temp_dir_name/dkms_source_tree" ] && [ -d "$temp_dir_name/dkms_binaries_only" ]; then
	PACKAGE_NAME=`cat $temp_dir_name/dkms_binaries_only/PACKAGE_NAME 2>/dev/null`
	PACKAGE_VERSION=`cat $temp_dir_name/dkms_binaries_only/PACKAGE_VERSION 2>/dev/null`
	if [ -z "$PACKAGE_NAME" ] || [ -z "$PACKAGE_VERSION" ]; then
	    echo $"" >>$std_err
	    echo $"Error! Tarball does not appear to be a correctly formed" >>$std_err
	    echo $"DKMS archive." >>$std_err
	    rm -rf $temp_dir_name
	    exit 5
	fi
	if [ "`$0 status -m $PACKAGE_NAME -v $PACKAGE_VERSION 2>/dev/null`" == "" ] && [ -z "$force" ]; then
	    echo $"" >>$std_err
	    echo $"Error! Tarball is a DKMS binaries-only archive, but your DKMS tree" >>$std_err
	    echo $"does not have the source installed for $PACKAGE_NAME-$PACKAGE_VERSION." >>$std_err
	    echo $"To load a DKMS binaries-only archive, you must already have the module" >>$std_err
	    echo $"source in your DKMS tree." >>$std_err
	    echo $"" >>$std_err
	    echo $"This can be overridden by using --force, but this is not recommended since" >>$std_err
	    echo $"it will eliminate your ability to actually build for this module." >>$std_err
	    exit 6
	elif [ "`$0 status -m $PACKAGE_NAME -v $PACKAGE_VERSION 2>/dev/null`" == "" ] && [ -n "$force" ]; then
	    if [ -e "$temp_dir_name/dkms_binaries_only/dkms.conf" ]; then
		echo $""
		echo $"Binaries-only DKMS tarball to be loaded for $PACKAGE_NAME-$PACKAGE_VERSION"
		echo $"even though source for this module is not added to the DKMS tree.  This"
		echo $"will allow you to install the pre-built binaries contained within this"
		echo $"tarball, but will prevent you from building new modules for other kernels."
		echo $""
		echo $"Creating $source_tree/$PACKAGE_NAME-$PACKAGE_VERSION..."
		rm -rf $source_tree/$PACKAGE_NAME-$PACKAGE_VERSION
		mkdir -p $source_tree/$PACKAGE_NAME-$PACKAGE_VERSION
		echo $"Copying dkms.conf to $source_tree/$PACKAGE_NAME-$PACKAGE_VERSION..."
		cp -rf $temp_dir_name/dkms_binaries_only/dkms.conf $source_tree/$PACKAGE_NAME-$PACKAGE_VERSION
	    else
		echo $"" >>$std_err
		echo $"Binaries-only DKMS tarball does not seem to contain a dkms.conf file for" >>$std_err
		echo $"this module.  Unable to load this tarball into the DKMS tree." >>$std_err
		exit 7
	    fi
	fi
	is_from_mktarball="true"
	is_binaries_only="true"
    elif [ -d "$temp_dir_name/dkms_source_tree" ]; then
	. $temp_dir_name/dkms_source_tree/dkms.conf 2>/dev/null
	if [ -z "$PACKAGE_NAME" ] || [ -z "$PACKAGE_VERSION" ]; then
	    echo $"" >>$std_err
	    echo $"Error! Tarball does not appear to be a correctly formed" >>$std_err
	    echo $"DKMS archive." >>$std_err
	    rm -rf $temp_dir_name
	    exit 8
	fi
	is_from_mktarball="true"
	tarball_source_tree_name="dkms_source_tree"
    else
	echo $"" >>$std_err
	echo $"Error! Tarball does not appear to be a correctly formed" >>$std_err
	echo $"DKMS archive." >>$std_err
	rm -rf $temp_dir_name
	exit 8
    fi

    # Is tarball from before DKMS 2.0 (prior to arch support)
    if [ "$is_from_mktarball" == "true" ] && ! [ -e "$temp_dir_name/dkms_main_tree/dkms_dbversion" ]; then
	is_not_arch_aware="true"
	echo $"" >>$std_err
	echo $"Warning!  This tarball was created with dkms < 2.0 and contains" >>$std_err
	echo $"no arch info. DKMS will assume the arch: ${arch_array[0]}" >>$std_err
    fi

    # Make sure we got what we needed from the tarball
    module="$PACKAGE_NAME"
    module_version="$PACKAGE_VERSION"

    echo $""
    echo $"Loading tarball for module: $module / version: $module_version"
    echo $""

    # Load the source from the tarball
    if [ -z "$is_binaries_only" ]; then
	if [ "`$0 status -m $module -v $module_version 2>/dev/null`" != "" ] && [ -z "$force" ]; then
	    echo $"Warning! Source for $module-$module_version already exists.  Skipping..." >>$std_err
	else
	    echo $"Loading $source_tree/$module-$module_version..."
	    rm -rf $source_tree/$module-$module_version
	    mkdir -p $source_tree/$module-$module_version
	    cp -rf $temp_dir_name/$tarball_source_tree_name/* $source_tree/$module-$module_version
	fi

	mkdir -p $dkms_tree/$module/$module_version
    fi

    # Load kernel directories
    [ -n "$is_not_arch_aware" ] && dirs_to_load=`find $temp_dir_name/dkms_main_tree -type d -maxdepth 1 -mindepth 1 2>/dev/null`
    [ -z "$is_not_arch_aware" ] && dirs_to_load=`find $temp_dir_name/dkms_main_tree -type d -maxdepth 2 -mindepth 2 2>/dev/null`
    for directory in $dirs_to_load; do
	dirs_to_parse=`echo $directory | sed "s#.*dkms_main_tree/##"`
	kernel_to_load=`echo $dirs_to_parse | sed "s#/.*##"`
	[ `echo $dirs_to_parse | grep -c "/"` -gt 0 ] && arch_to_load=`echo $dirs_to_parse | sed "s#.*/##"` || arch_to_load="${arch_array[0]}"

	dkms_dir_location="$dkms_tree/$module/$module_version/$kernel_to_load/$arch_to_load"
	if [ -d "$dkms_dir_location" ] && [ -z "$force" ]; then
	    echo $"Warning! $dkms_dir_location already exists.  Skipping..." >>$std_err
	else
	    echo $"Loading $dkms_dir_location..."
	    rm -rf $dkms_dir_location
	    mkdir -p $dkms_dir_location
	    cp -rf $directory/* $dkms_dir_location/
	fi
    done
    
    # Create source symlink
    if [ -h "$dkms_tree/$module/$module_version/source" ] && [ -z "$force" ]; then
	echo $"Warning! $dkms_tree/$module/$module_version/source already exists.  Skipping..." >>$std_err
    else
	echo $"Creating $dkms_tree/$module/$module_version/source symlink..."
	rm -f "$dkms_tree/$module/$module_version/source"
	ln -s "$source_tree/$module-$module_version" "$dkms_tree/$module/$module_version/source"
    fi
    
    # Clean up /tmp
    rm -rf $temp_dir_name
	
    echo $""
    echo $"DKMS: ldtarball Completed."
}

run_match ()
{
    setup_kernels_arches "match"
    set_kernel_source_dir "${kernelver_array[0]}"

    # Error if $template_kernel is unset
    if [ -z "$template_kernel" ]; then
	echo $"" >>$std_err
	echo $"Error! Invalid number of parameters passed." >>$std_err
	echo $"Usage: match --templatekernel=<kernel-version> -k <kernel-version>" >>$std_err
	echo $"   or: match --templatekernel=<kernel-version> -k <kernel-version> -m <module>" >>$std_err
	exit 1	
    fi  

    # Error out if $template_kernel = $kernel_version
    if [ "$template_kernel" == "${kernelver_array[0]}" ]; then
	echo $"" >>$std_err
	echo $"Error! The templatekernel and the specified kernel version are the same." >>$std_err
	exit 2
    fi

    # Set the IFS to split on new-lines and not on spaces
    IFS='
'
    # Read in the status of template_kernel
    local template_kernel_status=`$0 status -k $template_kernel -a ${arch_array[0]} | grep ": installed"`
    
    # If $module is set, grep the status only for that module
    if [ -n "$module" ]; then

        # Make sure that its installed in the first place
	if ! [ -d "$dkms_tree/$module/" ]; then
	    echo $"" >>$std_err
	    echo $"Error! The module: $module is not located in the DKMS tree." >>$std_err
	    unset IFS
	    exit 3
	fi

	template_kernel_status=`echo "$template_kernel_status" | grep "^$module,"`
    fi

    echo $""
    echo $"Matching modules in kernel: ${kernelver_array[0]} (${arch_array[0]})" 
    echo $"to the configuration of kernel: $template_kernel (${arch_array[0]})" 

    # Prepare the kernel just once but only if there is actual work to do
    if [ "$template_kernel_status" == "" ]; then
	echo $""
	echo $"There is nothing to be done for this match."
    else
	prepare_kernel "${kernelver_array[0]}" "${arch_array[0]}"

        # Iterate over the kernel_status and match kernel to the template_kernel
	for template_line in $template_kernel_status; do
	    template_module=`echo "$template_line" | awk {'print $1'} | sed 's/,$//'`
	    template_version=`echo "$template_line" | awk {'print $2'} | sed 's/,$//'`
	    
	    # Print out a match header
	    echo $"" 
	    echo $"---- Match Beginning ----" 
	    echo $"Module:  $template_module"  
	    echo $"Version: $template_version" 
	    echo $"-------------------------" 
	    
	    # Figure out what to do from here
	    if [ `$0 status -m "$template_module" -v "$template_version" -k "${kernelver_array[0]}" -a "${arch_array[0]}" 2>/dev/null | grep -c ": installed"` -eq 1 ]; then
		echo $"" 
		echo $"This module/version combo is already installed.  Nothing to be done." 
	    elif [ `$0 status -m "$template_module" -v "$template_version" -k "${kernelver_array[0]}" -a "${arch_array[0]}" 2>/dev/null | grep -c ": built"` -eq 1 ]; then
		unset IFS
		echo $"" 
		echo $"This module/version combo is built.  Installing it:" 
		module="$template_module"
		module_version="$template_version"
		install_module
		IFS='
'
	    else
		unset IFS
		echo $"" 
		echo $"Building & Installing this module/version:" 
		module="$template_module"
		module_version="$template_version"
		build_module "no-prepare-kernel"
		install_module
		IFS='
'
	    fi
	done

        # Clean up the kernel tree
	if [ -z "$no_clean_kernel" ]; then
	    cd "$kernel_source_dir"
	    [ -z "$kerneldoth_contents" ] && invoke_command "make mrproper >/dev/null 2>&1" "cleaning kernel tree (make mrproper)" background
	    [ -n "$config_contents" ] && echo "$config_contents" > .config
	    [ -n "$kerneldoth_contents" ] && echo "$kerneldoth_contents" > /boot/kernel.h
	    cd -
	fi
    fi

    # Return the IFS to its old state
    unset IFS
    
    # Done
    echo $"" 
    echo $"DKMS: match Completed."
}

make_rpm()
{
    setup_kernels_arches "mkrpm"

    # Error if $module_version is set but $module is not
    if [ -z "$module" ] || [ -z "$module_version" ]; then
        echo $"" >>$std_err
        echo $"Error! Invalid number of parameters passed." >>$std_err
        echo $"Usage: mkrpm [-m module] [-v module-version]" >>$std_err
        exit 1
    fi

    # Check that source symlink works
    if ! [ -d "$dkms_tree/$module/$module_version/source" ]; then
        echo $"" >>$std_err
        echo $"Error! DKMS tree does not contain: $module-$module_version" >>$std_err
        echo $"Build cannot continue without the proper tree." >>$std_err
        exit 2
    fi

    # Make sure that its installed in the first place
    if ! [ -d "$dkms_tree/$module/$module_version" ]; then
        echo $"" >>$std_err
        echo $"Error! The module/version combo: $module-$module_version" >>$std_err
        echo $"is not located in the DKMS tree." >>$std_err
        exit 3
    fi

    # Read the conf file
    read_conf "${kernelver_array[0]}" "${arch_array[0]}"
    if [ "$?" -ne 0 ]; then
        echo $"" >>$std_err
        echo $"Error! Bad conf file." >>$std_err
        echo $"Your dkms.conf is not valid." >>$std_err
        exit 4
    fi

    local rpm_basedir="$dkms_tree/$module/$module_version/rpm"

    echo $""
    if [ -e "$dkms_tree/$module/$module_version/source/$module-dkms-mkrpm.spec" ]; then
	echo $"Using $dkms_tree/$module/$module_version/source/$module-dkms-mkrpm.spec"
	SPECFILE="$dkms_tree/$module/$module_version/source/$module-dkms-mkrpm.spec"
    elif [ -e "/etc/dkms/template-dkms-mkrpm.spec" ]; then
	echo $"Using /etc/dkms/template-dkms-mkrpm.spec"
	SPECFILE="/etc/dkms/template-dkms-mkrpm.spec"
    else
	echo $"" >>$std_err
	echo $"Cannot find /etc/dkms/template-dkms-mkrpm.spec which is needed by" >>$std_err
	echo $"DKMS in order use mkrpm." >>$std_err
	exit 5
    fi
    
    # Run a dkms mktarball for use in the rpm
    local mktarball_line
    if [ -n "$source_only" ]; then
	mktarball_line="--source-only"
    else
	local i=0
	echo $""
	while [ $i -lt ${#kernelver_array[*]} ]; do
	    if ! [ -d "$dkms_tree/$module/$module_version/${kernelver_array[$i]}/${arch_array[$i]}" ]; then
		echo $"" >>$std_err
		echo $"You do not seem to have $module $module_version built for" >>$std_err
		echo $"${kernelver_array[$i]} (${arch_array[$i]}).  All modules must be in" >>$std_err
		echo $"the built state before you can use mkrpm." >>$std_err
		exit 5
	    fi
	    echo $"Marking ${kernelver_array[$i]} (${arch_array[$i]}) for RPM..."
	    mktarball_line="-k ${kernelver_array[$i]} -a ${arch_array[$i]} $mktarball_line"
	    i=$(($i + 1))
	done
    fi
    RPMS=`invoke_command "rpmbuild --define \"version $module_version\" --define \"module_name $module\" --define \"kernel_versions ${kernelver_array[*]}\" --define \"mktarball_line $mktarball_line\" -bb $SPECFILE 2>&1|grep ^Wrote" "rpmbuild"`
    if [ "$?" -eq 0 ]; then
	echo $"" 
	echo $"$RPMS"
	echo $""
        echo $"DKMS: mkrpm Completed."
    else
	echo $"" >>$std_err
	echo $"Error! There was a problem creating your rpm." >>$std_err
	exit 7
    fi
}

#############################
####                     #### 
#### Program Starts Here ####
####                     ####
#############################

# Set Path
if [ `echo $PATH | egrep -c ":/usr/sbin:|^/usr/sbin:|:/usr/sbin$"` -eq 0 ]; then
    PATH="$PATH:/usr/sbin"
fi
if [ `echo $PATH | egrep -c ":/sbin:|^/sbin:|:/sbin$"` -eq 0 ]; then
    PATH="$PATH:/sbin"
fi

# Set important variables
current_kernel=`uname -r`
dkms_tree="/var/lib/dkms"
source_tree="/usr/src"
install_tree="/lib/modules"
tmp_location="/tmp"
dkms_frameworkconf="/etc/dkms/framework.conf"

# Source in /etc/dkms_framework.conf
. $dkms_frameworkconf 2>/dev/null

# Clear out command line argument variables
module=""
module_version=""
template_kernel=""
distro=""
release=""
conf=""
kernel_config=""
archive_location=""
kernel_source_dir=""
ksourcedir_fromcli=""
action=""
force=""
no_prepare_kernel=""
no_clean_kernel=""
binaries_only=""
source_only=""
all=""
module_suffix=""
rpm_safe_upgrade=""
std_err="/dev/stderr"
unset directive_array
unset kernelver_array
unset arch_array

# Parse command line arguments
while [ $# -gt 0 ]; do
    case $1 in
	--module*|-m)
	    if echo $1 | grep '=' >/dev/null ; then
		module=`echo $1 | sed 's/^.*=//'`
            else
                module="$2"
                shift
            fi
            ;;
	-v)
	    if echo $1 | grep '=' >/dev/null ; then
		module_version=`echo $1 | sed 's/^.*=//'`
            else
                module_version="$2"
                shift
            fi
            ;;
	--kernelver*|-k)
	    if echo $1 | grep '=' >/dev/null ; then
		kernelver_array[${#kernelver_array[*]}]=`echo $1 | sed 's/^.*=//'`
            else
		kernelver_array[${#kernelver_array[*]}]="$2"
                shift
            fi
            ;;
	--distro*|-d)
	    if echo $1 | grep '=' >/dev/null ; then
		distro=`echo $1 | sed 's/^.*=//'`
	    else
		distro="$2"
		shift
	    fi
	    ;;
	--release*|-r)
	    if echo $1 | grep '=' >/dev/null ; then
		release=`echo $1 | sed 's/^.*=//'`
	    else
		release="$2"
		shift
	    fi
	    ;;	    
	--templatekernel*)
	    if echo $1 | grep '=' >/dev/null ; then
		template_kernel=`echo $1 | sed 's/^.*=//'`
            else
                template_kernel="$2"
                shift
            fi
            ;;
	-c)
	    if echo $1 | grep '=' >/dev/null ; then
		conf=`echo $1 | sed 's/^.*=//'`
            else
                conf="$2"
                shift
            fi
            ;;
	--quiet|-q)
	    exec >/dev/null 2>&1
	    ;;
	--version|-V)
	    echo $"dkms: 2.0.0"
	    exit 0
	    ;;
	--no-prepare-kernel)
	    no_prepare_kernel="no-prepare-kernel"
	    ;;
	--no-clean-kernel)
	    no_clean_kernel="no-clean-kernel"
	    ;;
	--binaries-only)
	    binaries_only="binaries-only"
	    ;;
	--source-only)
	    source_only="source-only"
	    ;;
	--force)
	    force="true"
	    ;;
	--all)
	    all="true"
	    ;;
	--rpm_safe_upgrade)
	    rpm_safe_upgrade="true"
	    ;;
	--dkmstree*)
	    if echo $1 | grep '=' >/dev/null ; then
		dkms_tree=`echo $1 | sed 's/^.*=//'`
            else
                dkms_tree="$2"
                shift
            fi
            ;;
	--sourcetree*)
	    if echo $1 | grep '=' >/dev/null ; then
		source_tree=`echo $1 | sed 's/^.*=//'`
            else
                source_tree="$2"
                shift
            fi
            ;;
	--installtree*)
	    if echo $1 | grep '=' >/dev/null ; then
		install_tree=`echo $1 | sed 's/^.*=//'`
            else
                install_tree="$2"
                shift
            fi
            ;;
	--config*)
	    if echo $1 | grep '=' >/dev/null ; then
		kernel_config=`echo $1 | sed 's/^.*=//'`
            else
                kernel_config="$2"
                shift
            fi
	    ;;
	--archive*)
	    if echo $1 | grep '=' >/dev/null ; then
		archive_location=`echo $1 | sed 's/^.*=//'`
            else
                archive_location="$2"
                shift
            fi
	    ;;
	--arch*|-a)
	    if echo $1 | grep '=' >/dev/null ; then
		arch_array[${#arch_array[*]}]=`echo $1 | sed 's/^.*=//'`
            else
		arch_array[${#arch_array[*]}]="$2"
                shift
            fi
            ;;
	--kernelsourcedir*)
	    if echo $1 | grep '=' >/dev/null ; then
		kernel_source_dir=`echo $1 | sed 's/^.*=//'`
            else
                kernel_source_dir="$2"
                shift
            fi
	    ksourcedir_fromcli="true"
	    ;;
	--directive*)
	    if echo $1 | grep '=' >/dev/null ; then
		directive_array[${#directive_array[*]}]=`echo $1 | sed 's/[^=]\+=//'`
            else
                directive_array[${#directive_array[*]}]="$2"
                shift
            fi
	    ;;
	-*|--*)
	    echo $"" >&2
	    echo $"Error!  Unknown option: $1" >&2
	    show_usage
	    exit 2
	    ;;
	*)
	    action="$action $1"
	    ;;
    esac
    shift
done

# Run the specified action
for action_to_run in $action; do
    case "$action_to_run" in
	add)
	    add_module
	    ;;
	remove)
	    # Make sure they're root
	    if [ `id -u` -ne 0 ]; then
		echo $"You must be root to use this command." >>$std_err
		exit 1
	    fi
	    remove_module
	    ;;
	build)
	    build_module $no_prepare_kernel
	    ;;
	install)
            # Make sure they're root
	    if [ `id -u` -ne 0 ]; then
		echo $"You must be root to use this command." >>$std_err
		exit 1
	    fi
	    install_module
	    ;;
	match)
	    # Make sure they're root
	    if [ `id -u` -ne 0 ]; then
		echo $"You must be root to use this command." >>$std_err
		exit 1
	    fi
	    run_match
	    ;;
	uninstall)
	    # Make sure they're root
	    if [ `id -u` -ne 0 ]; then
		echo $"You must be root to use this command." >>$std_err
		exit 1
	    fi
	    uninstall_module
	    ;;
	mkdriverdisk)
	    # Make sure they're root
	    if [ `id -u` -ne 0 ]; then
		echo $"You must be root to use this command." >>$std_err
		exit 1
	    fi
	    make_driver_disk
	    ;;	
	mktarball)
	    make_tarball
	    ;;	
	mkrpm)
	    make_rpm
	    ;;
	ldtarball)
	    # Make sure they're root
	    if [ `id -u` -ne 0 ]; then
		echo $"You must be root to use this command." >>$std_err
		exit 1
	    fi
	    load_tarball
	    ;;
	status)
	    show_status
	    ;;
	"")
	    echo "" >&2
	    echo $"Error! No action was specified.">>$std_err
	    show_usage
	    ;;
	*)
	    echo "" >&2
	    echo $"Error! Unknown action specified: $action_to_run" >>$std_err
	    show_usage
	    ;;
    esac
done

#!/bin/bash
#
#  Copyright (C) 2003 Dell Computer Corporation <gary_lerhaupt@dell.com>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#  Dynamic Kernel Module Support (DKMS)
#  by Gary Lerhaupt <gary_lerhaupt@dell.com>

function invoke_command ()
{
    exitval=0
    rm -f .tmp_exitval
    if [ -e .tmp_exitval ]; then
	echo $"invoke_command could not run!" >$std_err
	exit 1
    fi
    echo -en "$2..." 
    if [ "$3" == background ]; then
	(eval $1; echo "exitval=$?" >> .tmp_exitval) &
	while ! [ -e .tmp_exitval ]
	  do
	  sleep 3
	  echo -en "." 
	done
	. .tmp_exitval
	rm .tmp_exitval
    else
	eval $1; exitval=$?
    fi
    if [ $exitval -gt 0 ]; then
	echo -en "(bad exit status: $exitval)" 
	script_location=`dirname $0`
	echo $1 >> $script_location/.invoke_command.log
    fi
    echo -en "\n" 
    return $exitval
}

function readlink()
{
    # $1 = the symlink to read
    read_link=""
    if [ -L "$1" ]; then
	read_link="$1"
	while [ -L "$read_link" ]; do
	    read_link=`ls -l $read_link | sed 's/.*-> //'`
	done
    fi
}

function remake_initrd()
{
    # If its Red Hat's version of mkinitrd, we know what to do, otherwise we don't
    mkinitrd --version >/dev/null
    if [ "$?" -eq 0 ]; then
      	echo $"" 
	echo $"Saving old initrd as /boot/initrd-${kernel_version}_old.img" 
	mv -f "/boot/initrd-${kernel_version}.img" "/boot/initrd-${kernel_version}_old.img"
	echo $"Making new initrd as /boot/initrd-${kernel_version}.img" 
	invoke_command "mkinitrd -f /boot/initrd-${kernel_version}.img ${kernel_version}" "mkinitrd" background
	echo $"If your next boot fails, edit your bootloader file and revert" 
	echo $"to the _old initrd image." 
    else
	echo $""
	echo $"Calling mkinitrd (bad exit status 9 may occur)"
	invoke_command "mkinitrd >/dev/null 2>&1" "mkinitrd" background
    fi

    # Rerun lilo if necessary
    if ! [ -e /boot/grub/grub.conf ] && [ -e /etc/lilo.conf ]; then
	invoke_command "/sbin/lilo" "Updating lilo"
    fi
}

function show_usage ()
{
    echo $"Usage: $0 [action] [options]" >$std_err
    echo $"      [action]  = { add | remove | build | install | uninstall | match" >$std_err
    echo $"                    | mkdriverdisk | mktarball | ldtarball | status }" >$std_err
    echo $"      [options] = [-c dkms.conf-location] [-k kernel-version] [-m module]" >$std_err
    echo $"                  [-v module-version] [-d distro] [-q] [--force] [--all]" >$std_err
    echo $"                  [--postadd=script-location] [--postbuild=script-location]" >$std_err
    echo $"                  [--postinstall=script-location] [--postremove=script-location]" >$std_err
    echo $"                  [--templatekernel=kernel] [--config=kernel-.config-location]" >$std_err 
    echo $"                  [--directive='cli-directive=cli-value']" >$std_err
}

function read_conf ()
{
    return_value=0
    # Find which conf file to check
    if [ -n "$1" ]; then
	read_conf_file="$1"
    elif [ -n "$conf" ]; then
	read_conf_file="$conf"
    else
	read_conf_file="$dkms_tree/$module/$module_version/dkms.conf"
    fi

    # Clear variables
    MAKE=""
    LOCATION=""
    CLEAN=""
    MODULE_NAME=""
    REMAKE_INITRD=""
    MODULES_CONF_ALIAS_TYPE=""

    # Set variables supported in dkms.conf files (eg. $kernelver)
    kernelver="$kernel_version"

    # Source in the dkms.conf
    . $read_conf_file 2>/dev/null

    # Get the correct make command
    for make_subdirective in `grep "^MAKE_" "$read_conf_file" | sed 's/MAKE_//' | sed 's/=.*//'`; do
	if [ `echo "$kernel_version" | grep -c "$make_subdirective"` -gt 0 ]; then
	    subdirective_to_use="MAKE_$make_subdirective"
	    MAKE="${!subdirective_to_use}"
	fi
    done

    # Use the generic make command if kernel >= 2.5
    if [ -n "$gt2dot4" ]; then
	MAKE="make -C /lib/modules/$kernel_version/build SUBDIRS=$dkms_tree/$module/$module_version/build modules"
    fi

    # Source in the directive_array
    IFS='
'
    for directive in "${directive_array[*]}"; do
	directive_name=`echo $directive | sed 's/\([^=]\+\)=.*/\1/'`
	directive_value=`echo $directive | sed 's/[^=]\+=//'`
	[ -n "$directive" ] && export $directive_name="$directive_value"
	[ -n "$directive" ] && echo $"DIRECTIVE: $directive_name=\"$directive_value\""
    done
    unset IFS

    # Set variables
    make_command="$MAKE"
    location="/lib/modules/$kernel_version$LOCATION"
    clean="$CLEAN"
    module_name_list="$MODULE_NAME"
    remake_initrd="$REMAKE_INITRD"
    modules_conf_alias_type="$MODULES_CONF_ALIAS_TYPE"
    
    # Set modules_conf_array
    index=0
    var_to_check="MODULES_CONF$index"
    while [ -n "${!var_to_check}" ]; do
	modules_conf_array[$index]=${!var_to_check}
	index=$((index+1))
	var_to_check="MODULES_CONF$index"
    done

    # Set patch_array (including kernel specific patches)
    index=0
    var_to_check="PATCH$index"
    while [ -n "${!var_to_check}" ]; do
	patch_array[$index]="${!var_to_check}"
	index=$((index+1))
	var_to_check="PATCH$index"
    done
    for patch_subdirective in `grep "^PATCH_" "$read_conf_file" | sed 's/PATCH_//' | sed 's/=.*//'`; do
	if [ `echo "$kernel_version" | grep -c "$patch_subdirective"` -gt 0 ]; then
	    subdirective_to_use="PATCH_$patch_subdirective"
	    patch_array[$index]="${!subdirective_to_use}"
	    index=$((index+1))
	fi
    done

    # Set default values
    if [ -z "$module_name_list" ]; then
	module_name_list="$module"
    fi
    if [ `echo "$remake_initrd" | grep -ic "^y"` -gt 0 ]; then
	remake_initrd="yes"
    else
	remake_initrd=""
    fi

    # Fail if no make command
    if [ -z "$make_command" ]; then
	echo $"dkms.conf: Error! No 'MAKE' directive specified.">$std_err
	return_value=1
    fi

    # Fail if no location command
    if [ -z "$LOCATION" ]; then
	echo $"dkms.conf: Error! No 'LOCATION' directive specified.">$std_err
	return_value=1
    fi

    # Fail if bad location command
    if [ `echo "$LOCATION" | grep -c "^/kernel"` -eq 0 ]; then
	echo $"dkms.conf: Error! Directive 'LOCATION' does not begin with '/kernel'.">$std_err
	return_value=1
    fi

    # Warn if no clean command
    if [ -z "$clean" ]; then
	echo $"dkms.conf: Warning.  No 'CLEAN' directive specified. Assuming: make clean" >$std_err
	clean="make clean"
    fi

    return $return_value
}

function modulesconf_modify ()
{
    # Make modules.conf changes as necessary
    if [ "$1" == "add" ]; then

	# Add aliases
	if [ -n "$modules_conf_alias_type" ]; then
	    for module_name in $module_name_list; do
		module_name_after=`echo $module_name | sed 's/.*://' | sed 's/\..*//'`
		if [ `grep -c "alias ${modules_conf_alias_type}[0-9]* $module_name_after\b" /etc/modules.conf` -eq 0 ]; then
		    next_alias_number=$(( `grep "alias $modules_conf_alias_type" /etc/modules.conf | awk '{print $2}' | sed "s/$modules_conf_alias_type//" | sort -n | tail -1` + 1 ))
		    echo -e "alias ${modules_conf_alias_type}${next_alias_number} $module_name_after" >> /etc/modules.conf
		fi
	    done
	fi

	# Add anything else
	index=0
	while [ $index -lt ${#modules_conf_array[*]} ]; do
	    if [ -n "${modules_conf_array[$index]}" ] && [ `grep -c "${modules_conf_array[$index]}" "/etc/modules.conf"` -eq 0 ]; then
		echo -e "${modules_conf_array[$index]}" >> /etc/modules.conf
	    fi	    
	    index=$((index+1))
	done

    # Remove modules_conf entries from /etc/modules.conf
    elif [ "$1" == "delete" ]; then

	# Remove aliases (maybe)
	if [ -n "$modules_conf_alias_type" ]; then
	    for module_name in $module_name_list; do
		module_name_after=`echo $module_name | sed 's/.*://' | sed 's/\..*//'`
		if [ `find /lib/modules/$kernel_version/ -name "$module_name_after.*" | wc -l | awk '{print $1}'` -eq 0 ]; then
		    grep -v "alias ${modules_conf_alias_type}[0-9]* $module_name_after" /etc/modules.conf > /etc/modules.new
		    mv -f /etc/modules.new /etc/modules.conf
		fi
	    done
	fi

	# Remove everything else
	index=0
	while [ $index -lt ${#modules_conf_array[*]} ]; do
	    if [ -n "${modules_conf_array[$index]}" ]; then
		grep -v "${modules_conf_array[$index]}" "/etc/modules.conf" > /etc/modules.new
		mv -f /etc/modules.new /etc/modules.conf
	    fi	    
	    index=$((index+1))
	done
    fi
}

function etc_sysconfig_kernel_modify ()
{
    if [ -e "/etc/sysconfig/kernel" ] && [ -n "$remake_initrd" ]; then

        # Make /etc/sysconfig/kernel changes as necessary
	if [ "$1" == "add" ]; then
	    etc_sysconfig_kernel_modify "delete"
	    for module_name in $module_name_list; do
		module_name_after=`echo $module_name | sed 's/.*://' | sed 's/\..*//'`
		sed -e "s/INITRD_MODULES=\"\(.*\)\"/INITRD_MODULES=\"\1 $module_name_after\"/" /etc/sysconfig/kernel > /etc/sysconfig/kernel.new
		mv /etc/sysconfig/kernel.new /etc/sysconfig/kernel
	    done
	
        # Remove /etc/sysconfig/kernel entries
	elif [ "$1" == "delete" ]; then
	    for module_name in $module_name_list; do
		module_name_after=`echo $module_name | sed 's/.*://' | sed 's/\..*//'`
		sed -e "s/\(INITRD_MODULES.*\)$module_name_after\b\(.*\)/\1\2/" /etc/sysconfig/kernel > /etc/sysconfig/kernel.new
		mv /etc/sysconfig/kernel.new /etc/sysconfig/kernel
	    done
	fi
    fi
}

function add_module ()
{

    # Set the kernel_version if it remains unset
    if [ -z "$kernel_version" ]; then
	kernel_version="$current_kernel"
    fi

    # Check that we have all the arguments
    if [ -z "$module" ] || [ -z "$module_version" ]; then
	echo $"" >$std_err
	echo $"Error! Invalid number of arguments passed." >$std_err
	echo $"Usage: add [-m module] [-v module-version] [-c dkms.conf-location]" >$std_err
	exit 1
    fi

    if [ -z "$conf" ]; then
	conf="$source_tree/$module-$module_version/dkms.conf"
    fi
	
    # Check that /usr/src/$module-$module_version exists	
    if ! [ -d "$source_tree/$module-$module_version" ]; then
	echo $"" >$std_err
	echo $"Error! Could not find module source directory." >$std_err
	echo $"Directory: $source_tree/$module-$module_version does not exist." >$std_err
	exit 2
    fi

    # Check that this module-version hasn't already been added
    if [ -d "$dkms_tree/$module/$module_version" ]; then
	echo $"" >$std_err
	echo $"Error! DKMS tree already contains: $module-$module_version" >$std_err
	echo $"You cannot add the same module/version combo more than once." >$std_err
	exit 3
    fi

    # Check that the conf file exists or any other script specified
    if ! [ -e "$conf" ]; then
	echo $"" >$std_err
	echo $"Error! Could not locate dkms.conf file." >$std_err
	echo $"File: $conf does not exist." >$std_err
	exit 4
    fi
    if [ -n "$post_add" ] && ! [ -e "$post_add" ]; then
	echo $"" >$std_err
	echo $"Error! Could not locate postadd script." >$std_err
	echo $"File: $post_add does not exist." >$std_err
	exit 5
    fi
    if [ -n "$post_build" ] && ! [ -e "$post_build" ]; then
	echo $"" >$std_err
	echo $"Error! Could not locate postbuild script." >$std_err
	echo $"File: $post_build does not exist." >$std_err
	exit 5
    fi
    if [ -n "$post_install" ] && ! [ -e "$post_install" ]; then
	echo $"" >$std_err
	echo $"Error! Could not locate postinstall script." >$std_err
	echo $"File: $post_install does not exist." >$std_err
	exit 6
    fi
    if [ -n "$post_remove" ] && ! [ -e "$post_remove" ]; then
	echo $"" >$std_err
	echo $"Error! Could not locate postremove script." >$std_err
	echo $"File: $post_remove does not exist." >$std_err
	exit 7
    fi

    # Check the conf file for sanity
    read_conf "$conf"
    if [ "$?" -ne 0 ]; then
	echo $"" >$std_err
	echo $"Error! Bad conf file." >$std_err
	echo $"File: $conf does not represent a valid dkms.conf file" >$std_err
	exit 8
    fi
    
    # Create the necessary dkms tree structure
    mkdir -p "$dkms_tree/$module/$module_version/build"
    ln -s "$source_tree/$module-$module_version" "$dkms_tree/$module/$module_version/source"
    
    # Copy the dkms.conf file
    echo $"Copying $conf to: $dkms_tree/$module/$module_version/dkms.conf" 
    cp -f "$conf" "$dkms_tree/$module/$module_version/dkms.conf"
    
    # Copy any other scripts as necessary
    if [ -n "$post_add" ]; then
	echo $"Copying $post_add to: $dkms_tree/$module/$module_version/post_add" 
	cp -f "$post_add" "$dkms_tree/$module/$module_version/post_add"
	chmod u+x "$dkms_tree/$module/$module_version/post_add"
    fi
    if [ -n "$post_build" ]; then
	echo $"Copying $post_build to: $dkms_tree/$module/$module_version/post_build" 
	cp -f "$post_build" "$dkms_tree/$module/$module_version/post_build"
	chmod u+x "$dkms_tree/$module/$module_version/post_build"
    fi
    if [ -n "$post_install" ]; then
	echo $"Copying $post_install to: $dkms_tree/$module/$module_version/post_install" 
	cp -f "$post_install" "$dkms_tree/$module/$module_version/post_install"
	chmod u+x "$dkms_tree/$module/$module_version/post_install"
    fi
    if [ -n "$post_remove" ]; then
	echo $"Copying $post_remove to: $dkms_tree/$module/$module_version/post_remove" 
	cp -f "$post_remove" "$dkms_tree/$module/$module_version/post_remove"
	chmod u+x "$dkms_tree/$module/$module_version/post_remove"
    fi

    # Run the post_add script
    if [ -x "$dkms_tree/$module/$module_version/post_add" ]; then
	echo $"" 
	echo $"Running the post_add script:" 
	"$dkms_tree/$module/$module_version/post_add" 
    fi
    
    echo $"" 
    echo $"Add Completed." 
}

function prepare_kernel()
{
    # Set the kernel variables
    kernel_source_dir="/lib/modules/$kernel_version/build"

    # Check that kernel-source exists
    if ! [ -e "$kernel_source_dir/include" ]; then
	echo $"" >$std_err
	echo $"Error! Your kernel source for kernel $kernel_version is not" >$std_err
	echo $"installed. DKMS build requires kernel source to build modules." >$std_err
	exit 1	
    fi

    # Prepare kernel for module build
    echo $"" 
    echo $"Preparing kernel $kernel_version for module build:" 
    echo $"(This is not compiling a kernel, only just preparing kernel symbols)" 
    cd $kernel_source_dir
    config_contents=`cat .config 2>/dev/null`
    [ -n "$config_contents" ] && echo $"Storing current .config to be restored when complete"
    
    # Do preparation
    if [ -f /boot/vmlinuz.version.h ]; then
	echo $"Running UnitedLinux preparation routine"
	kernel_config="/boot/vmlinuz.config"
	invoke_command "make mrproper >/dev/null 2>&1" "make mrproper" background
	[ -n "$config_contents" ] && echo "$config_contents" > .config
	invoke_command "cp /boot/vmlinuz.version.h include/linux/version.h" "using /boot/vmlinux.version.h" 
	invoke_command "cp -f $kernel_config .config" "using $kernel_config" 
	invoke_command "make cloneconfig >/dev/null 2>&1" "make cloneconfig" background
	invoke_command "make CONFIG_MODVERSIONS=1 dep >/dev/null 2>&1" "make CONFIG_MODVERSIONS=1 dep" background
    else 
	echo $"Running Red Hat/Generic preparation routine"
	invoke_command "make mrproper >/dev/null 2>&1" "make mrproper" background
	[ -n "$config_contents" ] && echo "$config_contents" > .config

        # Fix Makefile up so that EXTRAVERSION matches the kernel_version extraversion
	echo $"editing kernel Makefile"
	extraversion=`echo "$kernel_version" | sed 's/.*-/-/'`
	sed "s/EXTRAVERSION *=.*/EXTRAVERSION = $extraversion/" Makefile 2>/dev/null > Makefile.new
	mv -f Makefile.new Makefile
	sed "s/EXTRAVERSION=.*/EXTRAVERSION = $extraversion/" Makefile 2>/dev/null > Makefile.new
	mv -f Makefile.new Makefile

        # If kernel_config is not set, look in default spot for .config (./configs/kernel-...)
	if [ -z "$kernel_config" ] && [ -d "$kernel_source_dir/configs" ]; then
	    arch_used=`uname -m`
	    kernel_trunc=`echo $kernel_version | sed 's/-.*//'`
	    for config_type in debug summit smp enterprise bigmem BOOT; do
		if [ `echo "$kernel_version" | grep "$config_type"` ]; then
		    [ "$config_type" == "BOOT" ] && arch_used="i386"
		    kernel_config="$kernel_source_dir/configs/kernel-$kernel_trunc-$arch_used-$config_type.config"
		fi
	    done
	    [ -z "$kernel_config" ] && kernel_config="$kernel_source_dir/configs/kernel-$kernel_trunc-$arch_used.config"
	fi
	
	# Warn if no config, otherwise use it
	if [ -z "$kernel_config" ]; then
	    echo $""
	    echo $"Warning! Cannot find a .config file to prepare your kernel with."
	    echo $"Try using the --config option to specify where one can be found."
	    echo $"Your build will likely fail because of this."
	else
	    echo $"using $kernel_config"
	    cp -f "$kernel_config" .config
	fi

	invoke_command "make oldconfig >/dev/null 2>&1" "make oldconfig" background
	[ -z "$gt2dot4" ] && invoke_command "make dep >/dev/null 2>&1" "make dep" background
    fi
    cd -
}

function install_module()
{
    # Set the kernel_version if it remains unset
    if [ -z "$kernel_version" ]; then
	kernel_version="$current_kernel"
    fi

    # Check that the right arguments were passed
    if [ -z "$module" ] || [ -z "$module_version" ]; then
	echo $"" >$std_err
	echo $"Error! Invalid number of parameters passed." >$std_err
	echo $"Usage: install [-m module] [-v module-version]" >$std_err
	exit 1
    fi

    # Check that $module-$module_version exists by checking the source symlink	
    if ! [ -d "$dkms_tree/$module/$module_version/source" ]; then
	echo $"" >$std_err
	echo $"Error! DKMS tree does not contain: $module-$module_version" >$std_err
	echo $"Build cannot continue without the proper tree." >$std_err
	exit 2
    fi

    # Read the conf file
    read_conf
    if [ "$?" -ne 0 ]; then
	echo $"" >$std_err
	echo $"Error! Bad conf file." >$std_err
	echo $"File: $dkms_tree/$module/$module_version/dkms.conf does not represent" $std_err
	echo $"a valid dkms.conf file." >$std_err
	exit 3
    fi

    # Make sure the $module_name exists
    for module_name in $module_name_list; do
	module_name_after=`echo $module_name | sed 's/.*://'`
	if ! [ -e "$dkms_tree/$module/$module_version/$kernel_version/module/$module_name_after" ]; then
	    echo $"" >$std_err
	    echo $"Error! Could not locate $module_name_after for module $module in the DKMS tree." >$std_err
	    echo $"You must run a dkms build for kernel $kernel_version first." >$std_err
	    exit 4
	fi
    done

    # Check that its not already installed (kernel symlink)
    readlink "$dkms_tree/$module/kernel-${kernel_version}"
    kernel_symlink="$read_link"
    if [ "$kernel_symlink" == "$module_version/$kernel_version" ]; then
	echo $"" >$std_err
	echo $"Error! This module/version combo is already installed" >$std_err
	echo $"for kernel: $kernel_version" >$std_err
	exit 5
    fi

    # Save the original_module if one exists, none have been saved before, and this is the first module for this kernel
    lib_tree="/lib/modules/$kernel_version"
    for module_name in $module_name_list; do
	module_name_before=`echo $module_name | sed 's/:.*//'`
	module_name_after=`echo $module_name | sed 's/.*://'`
	module_count=`find $lib_tree -name $module_name_after | wc -l | awk {'print $1'}`
	if ! [ -L "$dkms_tree/$module/kernel-$kernel_version" ] && [ "$module_count" -eq 1 ]; then
	    echo $"" 
	    echo $"Found an original module $module_name_after in /lib/modules/" 
	    echo $"Archiving it within the DKMS tree for uninstallation purposes." 
	    mkdir -p "$dkms_tree/$module/original_module/$kernel_version/"
	    mv -f `find $lib_tree -name $module_name_after` "$dkms_tree/$module/original_module/$kernel_version/"
	elif  ! [ -L "$dkms_tree/$module/kernel-$kernel_version" ] && [ "$module_count" -gt 1 ] && [ -e "$location/$module_name_after" ]; then
	    echo $""
	    echo $"Found multiple original modules $module_name_after in /lib/modules"
	    echo $"Archiving the one in in $LOCATION for uninstallation purposes."
	    echo $"Warning! Since multiple modules exist with the same name, problems"
	    echo $"may arise."
	    mkdir -p "$dkms_tree/$module/original_module/$kernel_version/"
	    mv -f "$location/$module_name_after" "$dkms_tree/$module/original_module/$kernel_version/"
	elif  ! [ -L "$dkms_tree/$module/kernel-$kernel_version" ] && [ "$module_count" -gt 1 ] && ! [ -e "$location/$module_name_after" ]; then
	    echo $""
	    echo $"Multiple original modules $module_name_after exist in /lib/modules"
	    echo $"Due to this confusion, DKMS cannot archive any of them for uninstallation."
	    echo $"Warning! Since multiple modules exist with the same name, problems"
	    echo $"may arise."	    
	else
	    rm -f "$location/$module_name_after" 2>/dev/null
	fi

        # Copy module to its location
	echo $""
 	echo $"Copying the new $module_name_after for $module to $location" 
	mkdir -p $location
	cp -f "$dkms_tree/$module/$module_version/$kernel_version/module/$module_name_after" "$location/$module_name_after"
    done
    
    # Create the kernel-<kernelver> symlink to designate this version as active
    rm -f "$dkms_tree/$module/kernel-$kernel_version" 2>/dev/null
    ln -s "$module_version/$kernel_version" "$dkms_tree/$module/kernel-$kernel_version" 2>/dev/null

    # Run the post_install script
    if [ -x "$dkms_tree/$module/$module_version/post_install" ]; then
	echo $"" 
	echo $"Running the post_install script:" 
	"$dkms_tree/$module/$module_version/post_install" 
    fi

    # Make modules.conf changes as necessary
    modulesconf_modify "add"
    etc_sysconfig_kernel_modify "add"

    # Run depmod if System.map-<kernel_version> exists
    if [ -e "/boot/System.map-$kernel_version" ]; then
	invoke_command "depmod -a $kernel_version -F /boot/System.map-$kernel_version" "depmod" background 
    fi

    # Do remake_initrd things (save old initrd)
    if [ -n "$remake_initrd" ]; then
	remake_initrd
    fi
     
    echo $"" 
    echo $"Install Completed." 
}


function build_module()
{
    # Set the kernel_version if it remains unset
    if [ -z "$kernel_version" ]; then
	kernel_version="$current_kernel"
    fi

    # Check that the right arguments were passed
    if [ -z "$module" ] || [ -z "$module_version" ]; then
	echo $"" >$std_err
	echo $"Error! Invalid number of parameters passed." >$std_err
	echo $"Usage: build [-m module] [-v module-version]" >$std_err
	exit 1
    fi
    
    # Set the kernel variables
    kernel_source_dir="/lib/modules/$kernel_version/build"

    # Check that source symlink works
    if ! [ -d "$dkms_tree/$module/$module_version/source" ]; then
	echo $"" >$std_err
	echo $"Error! DKMS tree does not contain: $module-$module_version" >$std_err
	echo $"Build cannot continue without the proper tree." >$std_err
	exit 2
    fi

    # Check that the module has not already been built for this kernel
    if [ -d "$dkms_tree/$module/$module_version/$kernel_version" ]; then
	echo $"" >$std_err
	echo $"Error! This module/version has already been installed on: $kernel_version" >$std_err
	echo $"The directory: $dkms_tree/$module/$module_version/$kernel_version already" >$std_err
	echo $"exists.  Use the dkms remove function before trying to install again." >$std_err
	exit 3
    fi
	
    # Read the conf file
    read_conf
    if [ "$?" -ne 0 ]; then
	echo $"" >$std_err
	echo $"Error! Bad conf file." >$std_err
	echo $"File: $dkms_tree/$module/$module_version/dkms.conf does not represent" >$std_err
	echo $"a valid dkms.conf file." >$std_err
	exit 4
    fi
    
    # Prepare the kernel for the module build
    if [ "$1" != "no-prepare-kernel" ]; then
	prepare_kernel
    fi
    
    # Set up temporary build directory for build
    rm -rf "$dkms_tree/$module/$module_version/build"
    cp -rf "$dkms_tree/$module/$module_version/source/" "$dkms_tree/$module/$module_version/build"
    cd "$dkms_tree/$module/$module_version/build"
    echo $"" 
    echo $"Building module:" 

    # Apply any patches
    index=0
    while [ $index -lt ${#patch_array[*]} ]; do
	if ! [ -e "$dkms_tree/$module/$module_version/build/patches/${patch_array[$index]}" ]; then
	    echo $"" >$std_err
	    echo $"Error!  Patch ${patch_array[$index]} as specified in dkms.conf cannot be" >$std_err
	    echo $"found in $dkms_tree/$module/$module_version/build/patches/." >$std_err
	    exit 5
	fi
	invoke_command "patch -p1 < ./patches/${patch_array[$index]}" "applying patch ${patch_array[$index]}"
	if [ "$?" -ne 0 ]; then
	    echo $"" >$std_err
	    echo $"Error! Application of patch ${patch_array[$index]} failed." >$std_err
	    echo $"Check $dkms_tree/$module/$module_version/build/ for more information." >$std_err
	    exit 6
	fi
	index=$((index+1))
    done

    # Build
    invoke_command "$clean >/dev/null 2>&1" "cleaning build area" background
    echo $"DKMS make.log for $module-$module_version for kernel $kernel_version" >> "$dkms_tree/$module/$module_version/build/make.log"
    echo $"`date`" >> "$dkms_tree/$module/$module_version/build/make.log"
    invoke_command "$make_command >> $dkms_tree/$module/$module_version/build/make.log 2>&1" "$make_command" background
    # Make sure all the modules built successfully
    for module_name in $module_name_list; do
	module_name_before=`echo $module_name | sed 's/:.*//'`
	if ! [ -e "$module_name_before" ]; then
	    echo $"" >$std_err
	    echo $"Error!  Module build failed for kernel: $kernel_version" >$std_err
	    echo $"Consult the make.log in the build directory" >$std_err
	    echo $"$dkms_tree/$module/$module_version/build/ for more information." >$std_err
	    exit 7
	fi
    done
    cd -

    # Build success, so create DKMS structure for a built module
    mkdir -p "$dkms_tree/$module/$module_version/$kernel_version/log"
    cp -f "$kernel_config" "$dkms_tree/$module/$module_version/$kernel_version/log/"  
    mv -f "$dkms_tree/$module/$module_version/build/make.log" "$dkms_tree/$module/$module_version/$kernel_version/log/make.log" 2>/dev/null   

    # Save a copy of the new module
    mkdir "$dkms_tree/$module/$module_version/$kernel_version/module" >/dev/null
    for module_name in $module_name_list; do
	module_name_before=`echo $module_name | sed 's/:.*//'`
	module_name_after=`echo $module_name | sed 's/.*://'`
	cp -f "$dkms_tree/$module/$module_version/build/$module_name_before" "$dkms_tree/$module/$module_version/$kernel_version/module/$module_name_after" >/dev/null
    done

    # Run the post_build script
    if [ -x "$dkms_tree/$module/$module_version/post_build" ]; then
	echo $"" 
	echo $"Running the post_build script:" 
	"$dkms_tree/$module/$module_version/post_build" 
    fi
    
    # Run the clean commands
    cd "$dkms_tree/$module/$module_version/build"
    invoke_command "$clean >/dev/null 2>&1" "cleaning build area" background
    cd -
    if [ "$1" != "no-prepare-kernel" ]; then
	cd "$kernel_source_dir"
	invoke_command "make mrproper >/dev/null 2>&1" "cleaning kernel tree (make mrproper)" background
	[ -n "$config_contents" ] && echo "$config_contents" > .config
	cd -
    fi

    # Clean the build directory
    rm -rf "$dkms_tree/$module/$module_version"/build/*

    echo $"" 
    echo $"Build Completed." 
}

function do_uninstall()
{
    echo $"" 
    echo $"--- Uninstall Beginning ---" 
    echo $"Module:  $module"  
    echo $"Version: $module_version" 
    echo $"Kernel:  $kernel_version" 
    echo $"---------------------------" 

    # If kernel-<kernelver> symlink points to this module, check for original_module and put it back
    was_active=""
    readlink "$dkms_tree/$module/kernel-${kernel_version}"
    kernel_symlink="$read_link"
    if [ "$kernel_symlink" == "$module_version/$kernel_version" ]; then
	was_active="true"
	echo $"" 
	echo $"Status: Before uninstall, this module version was ACTIVE on this kernel."
	for module_name in $module_name_list; do
	    module_name_before=`echo $module_name | sed 's/:.*//'`
	    module_name_after=`echo $module_name | sed 's/.*://'`
	    echo $""
	    echo $"Deleting $module_name_after from: $location" 
	    rm -f "$location/$module_name_after"
	    if [ -e "$dkms_tree/$module/original_module/$kernel_version/$module_name_after" ]; then
		echo $"Archived original_module $module_name_after found!  Reinstating it under the" 
		echo $"directory: $location" 
		cp -f "$dkms_tree/$module/original_module/$kernel_version/$module_name_after" "$location/" 2>/dev/null
	    else
		echo $"No original module $module_name_after was found for this module on this kernel." 
		echo $"Use the dkms install command to reinstall any previous module version." 
		
	        # Remove modules_conf entries from /etc/modules.conf
		modulesconf_modify "delete"
	    fi
	done
	rm -f "$dkms_tree/$module/kernel-$kernel_version"
    else
	echo $"" 
	echo $"Status: This module version was INACTIVE for this kernel." 
    fi

    # Run the post_remove script
    if [ -x "$dkms_tree/$module/$module_version/post_remove" ]; then
	echo $"" 
	echo $"Running the post_remove script:" 
	"$dkms_tree/$module/$module_version/post_remove" 
    fi

    # Run depmod if System.map-<kernel_version> exists
    if [ -e "/boot/System.map-$kernel_version" ]; then
	echo $""
	invoke_command "depmod -a $kernel_version -F /boot/System.map-$kernel_version" "depmod" background 
    fi
    
    # Do remake_initrd things (remake initrd)
    if [ -n "$remake_initrd" ]; then
	remake_initrd
    fi

    # Make sure modules.conf still has entries if they got removed above
    modulesconf_modify "add"

    # Delete the original_module if nothing for this kernel is installed anymore
    if [ -d "$dkms_tree/$module/original_module/$kernel_version" ] && [ -n "$was_active" ]; then
	echo $"" 
	echo $"Removing original_module from DKMS tree for kernel $kernel_version" 
	rm -rf "$dkms_tree/$module/original_module/$kernel_version" 2>/dev/null
    fi
    if [ `find "$dkms_tree/$module/original_module" -path "$dkms_tree/$module/original_module/*" 2>/dev/null | wc -l | awk '{print $1}'` -eq 0 ]; then
	rm -rf "$dkms_tree/$module/original_module" 2>/dev/null
    fi
    
    echo $"" 
    echo $"Uninstall finished." 
}

function uninstall_module ()
{
    # Set the kernel_version if it remains unset
    if [ -z "$kernel_version" ]; then
	kernel_version="$current_kernel"
    fi

    # Check that the right arguments were passed
    if [ -z "$module" ] || [ -z "$module_version" ]; then
	echo $"" >$std_err
	echo $"Error! Invalid number of parameters passed." >$std_err
	echo $"Usage: uninstall [-m module] [-v module-version]" >$std_err
	echo $"   or: uninstall [-m module] [-v module-version] [-k kernel-version]" >$std_err
	exit 1
    fi

    # Check that $module is in the dkms tree
    if ! [ -d "$dkms_tree/$module" ]; then
	echo $"" >$std_err
	echo $"Error! There are no instances of module: $module" >$std_err
	echo $"located in the DKMS tree." >$std_err
	exit 2
    fi

    # Make sure that its installed in the first place
    if ! [ -d "$dkms_tree/$module/$module_version" ]; then
	echo $"" >$std_err
	echo $"Error! The module/version combo: $module-$module_version" >$std_err
	echo $"is not located in the DKMS tree." >$std_err
	exit 3
    fi

    # Read the conf file
    read_conf
    if [ "$?" -ne 0 ]; then
	echo $"" >$std_err
	echo $"Error! Bad conf file." >$std_err
	echo $"File: $dkms_tree/$module/$module_version/dkms.conf does not represent" >$std_err
	echo $"a valid dkms.conf file." >$std_err
	exit 4
    fi

    # Only do stuff if module/module version is currently installed
    readlink "$dkms_tree/$module/kernel-${kernel_version}"
    kernel_symlink="$read_link"
    if [ "$kernel_symlink" == "$module_version/$kernel_version" ]; then
	do_uninstall
    else
	echo $"" >$std_err
	echo $"Error! The module $module $module_version is not currently installed." >$std_err
	echo $"This module is not currently ACTIVE for kernel $kernel_version." >$std_err
	exit 5
    fi
}

function remove_module ()
{
    # Check that the right arguments were passed
    if [ -z "$module" ] || [ -z "$module_version" ] || $([ -z "$kernel_version" ] && [ -z "$all" ]); then
	echo $"" >$std_err
	echo $"Error! Invalid number of parameters passed." >$std_err
	echo $"Usage: remove [-m module] [-v module-version] --all" >$std_err
	echo $"   or: remove [-m module] [-v module-version] [-k kernel-version]" >$std_err
	exit 1
    fi

    # Check that kernel_version and all aren't both set simultaneously
    if [ -n "$kernel_version" ] && [ -n "$all" ]; then
	echo $"" >$std_err
	echo $"Error!  There is confusion over what to remove." >$std_err
	echo $"You cannot set both --all and specify a kernel-version." >$std_err
	exit 2
    fi

    # Check that $module is in the dkms tree
    if ! [ -d "$dkms_tree/$module/$module_version" ]; then
	echo $"" >$std_err
	echo $"Error! There are no instances of module: $module" >$std_err
	echo $"$module_version located in the DKMS tree." >$std_err
	exit 3
    fi

    # If $kernel_version is set, make sure its there first before removing
    if [ -n "$kernel_version" ] && ! [ -d "$dkms_tree/$module/$module_version/$kernel_version" ]; then
	echo $"" >$std_err
	echo $"Error! There is no instance of $module $module_version" >$std_err
	echo $"for kernel $kernel_version located in the DKMS tree." >$std_err
	exit 4
    fi

    # Read the conf file
    read_conf
    if [ "$?" -ne 0 ]; then
	echo $"" >$std_err
	echo $"Error! Bad conf file." >$std_err
	echo $"File: $dkms_tree/$module/$module_version/dkms.conf does not represent" >$std_err
	echo $"a valid dkms.conf file." >$std_err
	exit 5
    fi

    # If kernel_version is unset, remove all installations of $module_version, otherwise just one kernel
    kernel_list=""
    if [ -z "$kernel_version" ]; then
	kernel_list="`ls $dkms_tree/$module/$module_version | grep -v "build\b" | grep -v "tarball\b" | grep -v "rpm\b"`"
    else
	kernel_list="$kernel_version"
    fi

    # Iterate over the kernel_list
    for kernel_in_tree in $kernel_list; do
	if [ -d "$dkms_tree/$module/$module_version/$kernel_in_tree" ] && ! [ -h "$dkms_tree/$module/$module_version/$kernel_in_tree" ]; then
	    kernel_version="$kernel_in_tree"
	    read_conf
	    if [ "$?" -ne 0 ]; then
		echo $"" >$std_err
		echo $"Error! Bad conf file." >$std_err
		echo $"File: $dkms_tree/$module/$module_version/dkms.conf does not represent" >$std_err
		echo $"a valid dkms.conf file." >$std_err
		exit 6
	    fi
	    do_uninstall
	    
            # Delete the $kernel_version part of the tree
	    rm -rf "$dkms_tree/$module/$module_version/$kernel_version"
	fi
    done

    # Delete the $module_version part of the tree if no other $module_version/$kernel_version dirs exist
    if [ -z "`find $dkms_tree/$module/$module_version/* -maxdepth 1 -type d | grep -v build$ | grep -v tarball$ | grep -v rpm$`"  ]; then
	echo $"" 
	echo $"------------------------------" 
	echo $"Deleting module version: $module_version" 
	echo $"completely from the DKMS tree." 
	echo $"------------------------------" 
	rm -rf "$dkms_tree/$module/$module_version"
	echo $"Done."
    fi

    # Get rid of any remnant directories if necessary
    if [ `ls "$dkms_tree/$module" | wc -w | awk '{print $1}'` -eq 0 ]; then
	rm -rf "$dkms_tree/$module" 2>/dev/null
       
	# Its now safe to completely remove references in modules.conf
	modulesconf_modify "delete"
	etc_sysconfig_kernel_modify "delete"
    fi
}

show_status ()
{
    # Error if $module_version is set but $module is not
    if [ -n "$module_version" ] && [ -z "$module" ]; then
	echo $"" >$std_err
	echo $"Error! Invalid number of parameters passed." >$std_err
	echo $"Usage: status" >$std_err
	echo $"   or: status [-m module]" >$std_err
	echo $"   or: status [-k kernel-version]" >$std_err
	echo $"   or: status [-m module] [-v module-version]" >$std_err
	exit 1	
    fi

    # Determine which modules to show status for
    status_shown=""
    if [ -n "$module" ]; then
	modules_needing_status="$module"
    else
	for filename in `ls "$dkms_tree"`; do
	    if [ -d "$dkms_tree/$filename" ] && ! [ -h "$dkms_tree/$filename" ]; then
		modules_needing_status="$modules_needing_status $filename"
	    fi
	done
    fi

    # Iterate over the modules
    for module_in_tree in $modules_needing_status; do

	# Make sure its in the tree
	if [ -d "$dkms_tree/$module_in_tree" ]; then
	
	    # Determine which versions to show status for
	    versions_needing_status=""
	    if [ -n "$module_version" ]; then
		versions_needing_status="$module_version"
	    else
		for filename in `ls "$dkms_tree/$module_in_tree"`; do
		    if [ -d "$dkms_tree/$module_in_tree/$filename" ] && ! [ -h "$dkms_tree/$module_in_tree/$filename" ] && [ "$filename" != "original_module" ]; then
			versions_needing_status="$versions_needing_status $filename"
		    fi
		done    
	    fi
	    
	    # Iterate over the versions
	    for version_in_tree in $versions_needing_status; do
		
     	        # Make sure its in the tree
		if [ -d "$dkms_tree/$module_in_tree/$version_in_tree" ]; then
		    
	            # Determine which kernels to show status for
		    kernels_needing_status=""
		    if [ -n "$kernel_version" ]; then
			kernels_needing_status="$kernel_version"
		    else
			for filename in `ls $dkms_tree/$module_in_tree/$version_in_tree | grep -v "build\b" | grep -v "tarball\b" | grep -v "rpm\b"`; do
			    if [ -d "$dkms_tree/$module_in_tree/$version_in_tree/$filename" ] && ! [ -h "$dkms_tree/$module_in_tree/$version_in_tree/$filename" ]; then
				kernels_needing_status="$kernels_needing_status $filename"
			    fi
			done    
		    fi
		    
	            # Iterate over the kernels
		    for kernel_in_tree in $kernels_needing_status; do
			
     	                # Make sure its in the tree
			if [ -d "$dkms_tree/$module_in_tree/$version_in_tree/$kernel_in_tree" ]; then
			    readlink "$dkms_tree/$module_in_tree/kernel-${kernel_in_tree}"
			    kernel_symlink="$read_link"
			    if [ "$kernel_symlink" == "$version_in_tree/$kernel_in_tree" ]; then
				activity_state="installed"
			    else
				activity_state="built"
			    fi
			    extra_status=""
			    if [ -d "$dkms_tree/$module_in_tree/original_module/$kernel_in_tree" ]; then
				extra_status=" (original_module exists)"
			    fi
			    if [ -e "$dkms_tree/$module_in_tree/$version_in_tree/$kernel_in_tree/driver_disk/$module_in_tree-$version_in_tree-$kernel_in_tree-dd.img" ]; then
				extra_status="$extra_status (driver_disk exists)"
			    fi
			    status_shown="true"
			    echo "$module_in_tree, $version_in_tree, $kernel_in_tree: $activity_state$extra_status" 
			fi
			
		    done

		    if [ "$kernels_needing_status" == "" ]; then
			status_shown="true"
			echo "$module_in_tree, $version_in_tree: added" 
		    fi
		    
		fi
		
	    done
	    
	fi
	
    done
    
    if [ -z "$status_shown" ]; then
	echo $"" >$std_err
	echo $"Nothing found within the DKMS tree for this status command." >$std_err
	echo $"If your modules were not installed with DKMS, they will not show up here." >$std_err
    fi
}

make_driver_disk ()
{
    # Check that the right arguments were passed
    if [ -z "$module" ] || [ -z "$module_version" ] || [ -z "$distro" ] || [ -z "$kernel_version" ]; then
	echo $"" >$std_err
	echo $"Error! Invalid number of parameters passed." >$std_err
	echo $"Usage: mkdriverdisk [-d distro] [-m module] [-v module-version] [-k kernel-version]" >$std_err
	exit 1
    fi   

    # Check that source symlink works
    if ! [ -d "$dkms_tree/$module/$module_version/source" ]; then
	echo $"" >$std_err
	echo $"Error! DKMS tree does not contain: $module-$module_version" >$std_err
	echo $"Build cannot continue without the proper tree." >$std_err
	exit 2
    fi

    # Confirm that distro is supported
    if [ "$distro" != "redhat" ]; then
	echo $"" >$std_err
	echo $"Error! Invalid distro argument." >$std_err
	echo $"Currently the only supported distro for this action is: redhat" >$std_err 
	exit 3
    fi

    # Read the conf file
    read_conf
    if [ "$?" -ne 0 ]; then
	echo $"" >$std_err
	echo $"Error! Bad conf file." >$std_err
	echo $"File: $dkms_tree/$module/$module_version/dkms.conf does not represent" >$std_err
	echo $"a valid dkms.conf file." >$std_err
	exit 4
    fi

    # Warn if non-sane kernel version
    if [ `echo $kernel_version | grep -c "BOOT"` -ne 1 ]; then
	echo $"" >$std_err
	echo $"Warning! Kernel version is not the BOOT variant of this kernel." >$std_err
    fi

    if ! [ `$0 status -m "$module" -v "$module_version" -k "$kernel_version" | grep -c '[: built,: installed]'` -gt 0 ]; then
	build_module
    fi

    # Create directory and necessary files
    mkdir -p "$dkms_tree/$module/$module_version/$kernel_version/driver_disk"
   
    # Copy files for the driver disk (or warn if not present)
    files_for_driverdisk="module-info disk-info modules.dep pcitable rhdd-6.1"
    files_into_driverdisk="modules.cgz"
    for file in $files_for_driverdisk; do
	if ! [ -e "$dkms_tree/$module/$module_version/source/$file" ]; then
	    echo $"" >$std_err
	    echo $"Warning! File: $file not found in $dkms_tree/$module/$module_version/source/" >$std_err
	else
	    files_into_driverdisk="$file $files_into_driverdisk"
	    cp -f "$dkms_tree/$module/$module_version/source/$file" "$dkms_tree/$module/$module_version/$kernel_version/driver_disk/" 2>/dev/null
	fi
    done

    # Create a list of modules to put into modules.cgz
    modules_cgz_list=""
    for module_name in $module_name_list; do
	module_name_after=`echo $module_name | sed 's/.*://'`
	modules_cgz_list="$dkms_tree/$module/$module_version/$kernel_version/module/$module_name_after\n${modules_cgz_list}"
    done

    # Create dos disk image
    image_name="$module-$module_version-$kernel_version-dd.img"  
    cd "$dkms_tree/$module/$module_version/$kernel_version/driver_disk/"
    rm -f $image_name
    echo $""
    echo $"Creating driver disk:"
    invoke_command "echo -e '$modules_cgz_list' | cpio -oH crc 2>/dev/null | gzip -9 > ./modules.cgz" "compressing modules.cgz" background
    invoke_command "dd if=/dev/zero of="./$image_name" bs=72k count=20 >/dev/null 2>&1" "making a blank floppy image" background
    invoke_command "mkdosfs ./$image_name >/dev/null 2>&1" "mkdosfs" background
    mkdir ./mnt
    invoke_command "mount -o loop $image_name ./mnt >/dev/null 2>&1" "loopback mounting disk image"
    for file in $files_into_driverdisk; do
	invoke_command "cp -f ./$file ./mnt/" "  copying $file to disk image"
    done
    invoke_command "umount ./mnt" "unmounting disk image"
    rm -rf ./mnt
    cd -
    echo $""
    echo $"Disk image location: $dkms_tree/$module/$module_version/$kernel_version/driver_disk/$image_name"
    echo $""
    echo $"Done."
}

make_tarball()
{
    # Error if $module_version is set but $module is not
    if [ -z "$module" ] || [ -z "$module_version" ]; then
	echo $"" >$std_err
	echo $"Error! Invalid number of parameters passed." >$std_err
	echo $"Usage: mktarball [-m module] [-v module-version]" >$std_err
	exit 1	
    fi

    # Check that source symlink works
    if ! [ -d "$dkms_tree/$module/$module_version/source" ]; then
	echo $"" >$std_err
	echo $"Error! DKMS tree does not contain: $module-$module_version" >$std_err
	echo $"Build cannot continue without the proper tree." >$std_err
	exit 2
    fi

    # Make sure that its installed in the first place
    if ! [ -d "$dkms_tree/$module/$module_version" ]; then
	echo $"" >$std_err
	echo $"Error! The module/version combo: $module-$module_version" >$std_err
	echo $"is not located in the DKMS tree." >$std_err
	exit 3
    fi

    # Create a list of possible built kernels for this module
    built_for_kernels=`dkms status -m $module -v $module_version | awk '{print $3}' | grep ":" | sed 's/://'`

    if [ -z "$built_for_kernels" ]; then
	echo $"" >$std_err
	echo $"Error!  There are no built modules for any kernels for $module" >$std_err
	echo $"$module_version.  Cannot create an empty tarball." >$std_err
	exit 4
    fi

    # Create the base list of things to archive
    files_in_tree=`find $dkms_tree/$module/$module_version -type f -maxdepth 1`
    things_to_archive="$source_tree/$module-$module_version $files_in_tree $dkms_tree/$module/$module_version/source"
    echo $""
    echo $"Marking $source_tree/$module-$module_version for archiving..."

    # Determine the kernel_versions to put in the tarball
    kernel_version=`echo $kernel_version | cut -d "," --output-delimiter " " -f 1-`
    kernel_version_list=""
    for kernel in $built_for_kernels; do
	if [ -z "$kernel_version" ] || [ `echo "$kernel_version" | grep -c "$kernel\b"` -gt 0 ]; then
	    things_to_archive="$things_to_archive $dkms_tree/$module/$module_version/$kernel"
	    if [ -z "$kernel_version_list" ]; then
		kernel_version_list="kernel$kernel"
	    else
		kernel_version_list="$kernel_version_list-kernel$kernel"
	    fi
	    echo $"Marking kernel $kernel for archiving..."
	fi
    done

    # If they specified a kernel(s), make sure everything is sane
    for kernel in $kernel_version; do
	if [ `echo "$built_for_kernels" | grep -c "$kernel\b"` -eq 0 ]; then
	    echo $"" >$std_err
	    echo $"Error! The kernel $kernel does not have modules built for" >$std_err
	    echo $"$module $module_version.  Cannot create archive." >$std_err
	    exit 5
	fi
    done

    # Make the tarball
    tar -czf $module-$module_version-$kernel_version_list.dkms.tar.gz $things_to_archive 2>/dev/null
    if [ "$?" -eq 0 ]; then
	mkdir -p $dkms_tree/$module/$module_version/tarball
	mv -f $module-$module_version-$kernel_version_list.dkms.tar.gz $dkms_tree/$module/$module_version/tarball/
	echo $""
	echo $"Tarball location: $dkms_tree/$module/$module_version/tarball/$module-$module_version-$kernel_version_list.dkms.tar.gz"
	echo $""
	echo $"Done."
    else
	echo $"" >$std_err
	echo $"Error! Failed to make tarball." >$std_err
	exit 6
    fi
}

load_tarball()
{
    # Error out of --config was not set with the tarball location
    if [ -z "$kernel_config" ]; then
	echo $"" >$std_err
	echo $"Error! Invalid number of parameters passed." >$std_err
	echo $"Usage: ldtarball [--config=tarball-location]" >$std_err
	exit 1	
    fi

    # Error out if $kernel_config does not exist
    if ! [ -e "$kernel_config" ]; then
	echo $"" >$std_err
	echo $"Error! Cannot locate $kernel_config." >$std_err
	echo $"File does not exist." >$std_err
	exit 2
    fi

    # Figure out what kind of archive it is (tar.gz, tar, tar.bz, etc)
    tar_options=""
    if `gzip -t $kernel_config 2>/dev/null`; then
	tar_options="${tar_options}z"
    fi
    if `bzip2 -t $kernel_config 2>/dev/null`; then
	tar_options="${tar_options}j"
    fi

    # Untar it into /tmp
    tar -${tar_options}xf $kernel_config -C /tmp 

    # Figure out tar_dkms_tree
    for file_named_source in `tar -${tar_options}tf $kernel_config | grep "source$"`; do
	if [ -h "/tmp/$file_named_source" ]; then
	    chopped_tar_dkms_tree=`echo $file_named_source | sed 's/\(.*\)\/.*\/.*\/source/\1/'`
	    tar_dkms_tree="/$chopped_tar_dkms_tree"
	fi
    done

    # Figure out which module and module-version we're loading
    module=`tar -${tar_options}tf $kernel_config | grep "$chopped_tar_dkms_tree" | head -1 | sed 's/var\/dkms\///' | sed 's/\/.*//'`
    module_version=`tar -${tar_options}tf $kernel_config | grep "$chopped_tar_dkms_tree" | head -1 | sed "s/var\/dkms\/$module\///" | sed 's/\/.*//'`
    
    # Make sure its a sane tarball
    if [ -z "$module" ] || [ -z "$module_version" ]; then
	echo $"" >$std_err
	echo $"Error! Tarball does not appear to be correctly formed." >$std_err
	echo $"Could not decipher which module/module_version it contained." >$std_err
	exit 3
    fi

    echo $""
    echo $"Loading tarball for module: $module / version: $module_version"
    echo $""

    # Determine the source location in the tarball
    readlink "/tmp/$chopped_tar_dkms_tree/$module/$module_version/source"
    tar_source_location="$read_link"
    tar_source_tree=`echo $tar_source_location | sed 's/\/$//' | sed 's/\(.*\)\/.*/\1/'`

    # Load the source from the tarball
    if [ "`dkms status -m $module -v $module_version`" != "" ] && [ -z "$force" ]; then
	echo $"Warning! Source for $module-$module_version already exists.  Skipping..."
    else
	echo $"Loading $source_tree/$module-$module_version..."
	rm -rf $source_tree/$module-$module_version
	mkdir -p $source_tree/$module-$module_version
	cp -rf /tmp$tar_source_tree/$module-$module_version/* $source_tree/$module-$module_version
    fi

    mkdir -p $dkms_tree/$module/$module_version

    # Load config files & scripts
    files_to_load=`find /tmp/$chopped_tar_dkms_tree/$module/$module_version -type f -maxdepth 1`
    for filename in $files_to_load; do
	dkms_file_location="$dkms_tree`echo $filename | sed 's/\/tmp//' | sed "s#$tar_dkms_tree##"`"
	if [ -e "$dkms_file_location" ] && [ -z "$force" ]; then
	    echo $"Warning! $dkms_file_location already exists.  Skipping..."
	else
	    cp -f $filename $dkms_file_location
	    echo "Loading $dkms_file_location..."
	fi
    done

    # Load kernel directories
    dirs_to_load=`find /tmp/$chopped_tar_dkms_tree/$module/$module_version -type d -maxdepth 1 -mindepth 1`
    for directory in $dirs_to_load; do
	dkms_dir_location="$dkms_tree`echo $directory | sed 's/\/tmp//' | sed "s#$tar_dkms_tree##"`"
	if [ -d "$dkms_dir_location" ] && [ -z "$force" ]; then
	    echo $"Warning! $dkms_dir_location already exists.  Skipping..."
	else
	    echo $"Loading $dkms_dir_location..."
	    rm -rf $dkms_dir_location
	    mkdir -p $dkms_dir_location
	    cp -rf $directory/* $dkms_dir_location
	fi
    done
    
    # Create source symlink
    rm -f "$dkms_tree/$module/$module_version/source"
    ln -s "$source_tree/$module-$module_version" "$dkms_tree/$module/$module_version/source"
}

run_match ()
{
    # Error if $template_kernel or $kernel_version are unset
    if [ -z "$template_kernel" ] || [ -z "$kernel_version" ]; then
	echo $"" >$std_err
	echo $"Error! Invalid number of parameters passed." >$std_err
	echo $"Usage: match [--templatekernel=kernel-version] [-k kernel-version]" >$std_err
	echo $"   or: match [--templatekernel=kernel-version] [-k kernel-version] [-m module]" >$std_err
	exit 1	
    fi  

    # Error out if $template_kernel = $kernel_version
    if [ "$template_kernel" == "$kernel_version" ]; then
	echo $"" >$std_err
	echo $"Error! The templatekernel and the specified kernel version are the same." >$std_err
	exit 2
    fi

    # Set the IFS to split on new-lines and not on spaces
    IFS='
'
    # Read in the status of template_kernel
    template_kernel_status=`$0 status -k $template_kernel | grep ": installed"`
    
    # If $module is set, grep the status only for that module
    if [ -n "$module" ]; then

        # Make sure that its installed in the first place
	if ! [ -d "$dkms_tree/$module/" ]; then
	    echo $"" >$std_err
	    echo $"Error! The module: $module is not located in the DKMS tree." >$std_err
	    unset IFS
	    exit 3
	fi

	template_kernel_status=`echo "$template_kernel_status" | grep "^$module,"`
    fi

    echo $""
    echo $"Matching modules in kernel: $kernel_version" 
    echo $"to the configuration of kernel: $template_kernel" 

    # Prepare the kernel just once but only if there is actual work to do
    if [ "$template_kernel_status" == "" ]; then
	echo $""
	echo $"There is nothing to be done for this match."
    else
	prepare_kernel

        # Iterate over the kernel_status and match kernel to the template_kernel
	for template_line in $template_kernel_status; do
	    template_module=`echo "$template_line" | sed 's/\(.*\), .*, .*:.*/\1/'`
	    template_version=`echo "$template_line" | sed 's/.*, \(.*\), .*: .*/\1/'`
	    
	    # Print out a match header
	    echo $"" 
	    echo $"---- Match Beginning ----" 
	    echo $"Module:  $template_module"  
	    echo $"Version: $template_version" 
	    echo $"-------------------------" 
	    
	    # Figure out what to do from here
	    if [ `$0 status -m "$template_module" -v "$template_version" -k "$kernel_version" 2>/dev/null | grep -c ": installed"` -eq 1 ]; then
		echo $"" 
		echo $"This module/version combo is already installed.  Nothing to be done." 
	    elif [ `$0 status -m "$template_module" -v "$template_version" -k "$kernel_version" 2>/dev/null | grep -c ": built"` -eq 1 ]; then
		unset IFS
		echo $"" 
		echo $"This module/version combo is built.  Installing it:" 
		module="$template_module"
		module_version="$template_version"
		install_module
		IFS='
'
	    else
		unset IFS
		echo $"" 
		echo $"Building & Installing this module/version:" 
		module="$template_module"
		module_version="$template_version"
		build_module "no-prepare-kernel"
		install_module
		IFS='
'
	    fi
	done
    fi

    # Return the IFS to its old state
    unset IFS

    # Clean up the kernel tree
    cd "/lib/modules/$kernel_version/build"
    invoke_command "make mrproper >/dev/null 2>&1" "Cleaning kernel tree (make mrproper)" background
    if [ -n "$config_contents" ]; then
	echo "$config_contents" > .config
    fi
    cd -
    
    # Done
    echo $"" 
    echo $"Match Completed."
}

#############################
####                     #### 
#### Program Starts Here ####
####                     ####
#############################

# Set important variables
current_kernel=`uname -r`
dkms_tree="/var/dkms"
source_tree="/usr/src"
dkms_frameworkconf="/etc/dkms_framework.conf"

# Source in /etc/dkms_framework.conf
. /etc/dkms_framework.conf 2>/dev/null

# Clear out command line argument variables
module=""
module_version=""
kernel_version=""
template_kernel=""
distro=""
conf=""
post_add=""
post_build=""
post_remove=""
post_install=""
kernel_config=""
action=""
force=""
all=""
gt2dot4=""
std_err="/dev/stderr"

# Set up arrays
declare -a directive_array

# Parse command line arguments
action_flag=""
while [ $# -gt 0 ]; do
    case $1 in
	--module*|-m)
	    if echo $1 | grep '=' >/dev/null ; then
		module=`echo $1 | sed 's/^.*=//'`
            else
                module="$2"
                shift
            fi
            ;;
	-v)
	    if echo $1 | grep '=' >/dev/null ; then
		module_version=`echo $1 | sed 's/^.*=//'`
            else
                module_version="$2"
                shift
            fi
            ;;
	--kernelver*|-k)
	    if echo $1 | grep '=' >/dev/null ; then
		kernel_version=`echo $1 | sed 's/^.*=//'`
            else
                kernel_version="$2"
                shift
            fi
	    [ `echo $kernel_version | cut -d "." -f 1-1` -gt 1 ] && [ `echo $kernel_version | cut -d "." -f 2-2` -gt 4 ] && gt2dot4="true"
            ;;
	--distro*|-d)
	    if echo $1 | grep '=' >/dev/null ; then
		distro=`echo $1 | sed 's/^.*=//'`
	    else
		distro="$2"
		shift
	    fi
	    ;;
	--templatekernel*)
	    if echo $1 | grep '=' >/dev/null ; then
		template_kernel=`echo $1 | sed 's/^.*=//'`
            else
                template_kernel="$2"
                shift
            fi
            ;;
	-c)
	    if echo $1 | grep '=' >/dev/null ; then
		conf=`echo $1 | sed 's/^.*=//'`
            else
                conf="$2"
                shift
            fi
            ;;
	--quiet|-q)
	    exec >/dev/null 2>&1
	    ;;
	--version|-V)
	    echo $"dkms: 0.33.02"
	    exit 0
	    ;;
	--force)
	    force="true"
	    ;;
	--all)
	    all="true"
	    ;;
	--dkmstree*)
	    if echo $1 | grep '=' >/dev/null ; then
		dkms_tree=`echo $1 | sed 's/^.*=//'`
            else
                dkms_tree="$2"
                shift
            fi
            ;;
	--sourcetree*)
	    if echo $1 | grep '=' >/dev/null ; then
		source_tree=`echo $1 | sed 's/^.*=//'`
            else
                source_tree="$2"
                shift
            fi
            ;;
	--postadd*)
	    if echo $1 | grep '=' >/dev/null ; then
		post_add=`echo $1 | sed 's/^.*=//'`
            else
                post_add="$2"
                shift
            fi
            ;;
	--postbuild*)
	    if echo $1 | grep '=' >/dev/null ; then
		post_build=`echo $1 | sed 's/^.*=//'`
            else
                post_build="$2"
                shift
            fi
            ;;
	--postremove*)
	    if echo $1 | grep '=' >/dev/null ; then
		post_remove=`echo $1 | sed 's/^.*=//'`
            else
                post_remove="$2"
                shift
            fi
            ;;
	--postinstall*)
	    if echo $1 | grep '=' >/dev/null ; then
		post_install=`echo $1 | sed 's/^.*=//'`
            else
                post_install="$2"
                shift
            fi
            ;;
	--config*)
	    if echo $1 | grep '=' >/dev/null ; then
		kernel_config=`echo $1 | sed 's/^.*=//'`
            else
                kernel_config="$2"
                shift
            fi
	    ;;
	--directive*)
	    if echo $1 | grep '=' >/dev/null ; then
		directive_array[${#directive_array[*]}]=`echo $1 | sed 's/[^=]\+=//'`
            else
                directive_array[${#directive_array[*]}]="$2"
                shift
            fi
	    ;;
	-*|--*)
	    echo $"" >&2
	    echo $"Error!  Unknown option: $1" >&2
	    show_usage
	    exit 2
	    ;;
	*)
	    if [ -n "$action_flag" ]; then
		echo $"" >&2
		echo $"Error!  Multiple actions specified: $action, $1" >&2
		show_usage
		exit 3
	    fi
	    action_flag="set"
	    action="$1"
	    ;;
    esac
    shift
done

# Run the specified action
case "$action" in
    start)
        # ignore
	;;
    stop)
	# ignore
	;;
    add)
	add_module
	;;
    remove)
	# Make sure they're root
	if [ `id -u` -ne 0 ]; then
	    echo $"You must be root to use this command." >$std_err
	    exit 1
	fi
	remove_module
	;;
    build)
	build_module
	;;
    install)
        # Make sure they're root
	if [ `id -u` -ne 0 ]; then
	    echo $"You must be root to use this command." >$std_err
	    exit 1
	fi
	install_module
	;;
    match)
	# Make sure they're root
	if [ `id -u` -ne 0 ]; then
	    echo $"You must be root to use this command." >$std_err
	    exit 1
	fi
	run_match
	;;
    uninstall)
	# Make sure they're root
	if [ `id -u` -ne 0 ]; then
	    echo $"You must be root to use this command." >$std_err
	    exit 1
	fi
	uninstall_module
	;;
    mkdriverdisk)
	# Make sure they're root
	if [ `id -u` -ne 0 ]; then
	    echo $"You must be root to use this command." >$std_err
	    exit 1
	fi
	make_driver_disk
	;;	
    mktarball)
	make_tarball
	;;	
    ldtarball)
	# Make sure they're root
	if [ `id -u` -ne 0 ]; then
	    echo $"You must be root to use this command." >$std_err
	    exit 1
	fi
	load_tarball
	;;
    status)
	show_status
	;;
    "")
	echo "" >&2
	echo $"Error! No action was specified.">$std_err
	show_usage
	;;
    *)
	echo "" >&2
	echo $"Error! Unknown action specified: $action" >$std_err
	show_usage
	;;
esac

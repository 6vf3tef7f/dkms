#!/bin/bash
#
#  Copyright (C) 2003 Dell Computer Corporation <gary_lerhaupt@dell.com>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#  Dynamic Kernel Module Support (DKMS)
#  by Gary Lerhaupt <gary_lerhaupt@dell.com>

function invoke_command ()
{
    exitval=0
    exitval_file=`mktemp $tmp_location/dkms.XXXXXX`
    echo -en "$2..." 
    if [ "$3" == background ]; then
	(eval $1; echo "exitval=$?" >> "$exitval_file") &
	while [ -e "$exitval_file" ] && ! [ -s "$exitval_file" ]; do
	    sleep 3
	    echo -en "." 
	done
	. "$exitval_file"
    else
	eval $1; exitval=$?
    fi
    if [ $exitval -gt 0 ]; then
	echo -en "(bad exit status: $exitval)" 
	echo $1 >> "$exitval_file"
    else
	rm -f "$exitval_file"
    fi
    echo -en "\n" 
    return $exitval
}

function readlink()
{
    # $1 = the symlink to read
    read_link=""
    if [ -L "$1" ]; then
	read_link="$1"
	while [ -L "$read_link" ]; do
	    read_link=`ls -l $read_link | sed 's/.*-> //'`
	done
    fi
}

function remake_initrd()
{
    # If its Red Hat's version of mkinitrd, we know what to do, otherwise we don't
    mkinitrd --version >/dev/null
    if [ "$?" -eq 0 ]; then
      	echo $"" 
	echo $"Saving old initrd as /boot/initrd-${kernel_version}_old.img" 
	cp -f "/boot/initrd-${kernel_version}.img" "/boot/initrd-${kernel_version}_old.img"
	echo $"Making new initrd as /boot/initrd-${kernel_version}.img" 
	invoke_command "mkinitrd -f /boot/initrd-${kernel_version}.img ${kernel_version}" "mkinitrd" background
	echo $"If your next boot fails, edit your bootloader file and revert" 
	echo $"to the _old initrd image." 
    else
	echo $""
	echo $"Calling mkinitrd (bad exit status 9 may occur)"
	invoke_command "mkinitrd >/dev/null 2>&1" "mkinitrd" background
    fi

    # Rerun lilo if necessary
    if ! [ -e /boot/grub/grub.conf ] && [ -e /etc/lilo.conf ]; then
	invoke_command "/sbin/lilo" "Updating lilo"
    fi
}

function show_usage ()
{
    echo $"Usage: $0 [action] [options]" 
    echo $"  [action]  = { add | remove | build | install | uninstall | match" 
    echo $"               | mkdriverdisk | mktarball | ldtarball | status }" 
    echo $"  [options] = [-k kernel-version] [-m module] [-v module-version]" 
    echo $"              [-d distro] [-c dkms.conf-location] [-q] [--force] [--all]" 
    echo $"              [--templatekernel=kernel] [--directive='cli-directive=cli-value']"  
    echo $"              [--config=kernel-.config-location] [--archive=tarball-location]"  
}

function read_conf ()
{
    return_value=0
    # Find which conf file to check
    if [ -n "$1" ]; then
	read_conf_file="$1"
    elif [ -n "$conf" ]; then
	read_conf_file="$conf"
    else
	read_conf_file="$dkms_tree/$module/$module_version/source/dkms.conf"
    fi

    # Clear variables
    MAKE=""
    CLEAN=""
    REMAKE_INITRD=""
    MODULES_CONF_ALIAS_TYPE=""
    PACKAGE_NAME=""
    PACKAGE_VERSION=""
    BUILT_MODULE_NAME=""
    BUILT_MODULE_LOCATION=""
    DEST_MODULE_NAME=""
    DEST_MODULE_LOCATION=""
    POST_ADD=""
    POST_BUILD=""
    POST_INSTALL=""
    POST_REMOVE=""

    # Set variables supported in dkms.conf files (eg. $kernelver)
    kernelver="$kernel_version"
    [ -z "$kernel_source_dir" ] && kernel_source_dir="/lib/modules/$kernel_version/build"

    # Source in the dkms.conf
    . $read_conf_file 2>/dev/null

    # Source in the directive_array
    IFS='
'
    for directive in "${directive_array[*]}"; do
	directive_name=`echo $directive | sed 's/\([^=]\+\)=.*/\1/'`
	directive_value=`echo $directive | sed 's/[^=]\+=//'`
	[ -n "$directive" ] && export $directive_name="$directive_value"
	[ -n "$directive" ] && echo $"DIRECTIVE: $directive_name=\"$directive_value\""
    done
    unset IFS

    # Set variables
    clean="$CLEAN"
    modules_conf_alias_type="$MODULES_CONF_ALIAS_TYPE"
    package_name="$PACKAGE_NAME"
    package_version="$PACKAGE_VERSION"
    post_add="$POST_ADD"
    post_build="$POST_BUILD"
    post_install="$POST_INSTALL"
    post_remove="$POST_REMOVE"

    # Set module naming/location arrays
    index=0
    array_size=`echo -e "${#BUILT_MODULE_NAME[*]}\n${#BUILT_MODULE_LOCATION[*]}\n${#DEST_MODULE_NAME[*]}\n${#DEST_MODULE_LOCATION[*]}\n" | sort -n | tail -1`
    while [ "$index" -lt "$array_size" ]; do
	# Set values
	built_module_name[$index]=${BUILT_MODULE_NAME[$index]}
	built_module_location[$index]=${BUILT_MODULE_LOCATION[$index]}
	dest_module_name[$index]=${DEST_MODULE_NAME[$index]}
	dest_module_location[$index]=${DEST_MODULE_LOCATION[$index]}

	# If unset, set by defaults
	[ -z "${built_module_name[$index]}" ] && [ "${#DEST_MODULE_LOCATION[*]}" -eq 1 ] && built_module_name[$index]=$module
	[ -z "${dest_module_name[$index]}" ] && dest_module_name[$index]=${built_module_name[$index]}
	[ -n "${built_module_location[$index]}" ] && [ `echo ${built_module_location[$index]} | grep -c "\/$"` -eq 0 ] && built_module_location[$index]="${built_module_location[$index]}/"

	# FAIL if no built_module_name
	if [ -z "${built_module_name[$index]}" ]; then
	    echo $"dkms.conf: Error! No 'BUILT_MODULE_NAME' directive specified for record #$index." >$std_err
	    return_value=1
	fi

	# FAIL if built_module_name has .o or .ko in it
	if [ `echo "${built_module_name[$index]}" | grep -c "\.k\?o$"` -gt 0 ]; then
	    echo $"dkms.conf: Error! 'BUILT_MODULE_NAME' directive includes phrase '.o' or '.ko' in record #$index." >$std_err
	    return_value=1
	fi

	# FAIL if dest_module_name has .o or .ko in it
	if [ `echo "${dest_module_name[$index]}" | grep -c "\.k\?o$"` -gt 0 ]; then
	    echo $"dkms.conf: Error! 'DEST_MODULE_NAME' directive includes phrase '.o' or '.ko' in record #$index." >$std_err
	    return_value=1
	fi
	
        # Fail if no DEST_MODULE_LOCATION 
	if [ -z "${DEST_MODULE_LOCATION[$index]}" ]; then
	    echo $"dkms.conf: Error! No 'DEST_MODULE_LOCATION' directive specified for record #$index.">$std_err
	    return_value=1
	fi
	
        # Fail if bad DEST_MODULE_LOCATION
	if [ `echo "${DEST_MODULE_LOCATION[$index]}" | grep -c "^/kernel"` -eq 0 ]; then
	    echo $"dkms.conf: Error! Directive 'DEST_MODULE_LOCATION' does not begin with '/kernel' in record #$index.">$std_err
	    return_value=1
	fi

	index=$(($index+1))
    done

    # Get the correct make command
    index=1
    make_command="${MAKE[0]}"
    while [ "$index" -lt "${#MAKE[*]}" ]; do
	if [ -n "${MAKE[$index]}" ] && [ -n "${MAKE_MATCH[$index]}" ] && [ `echo $kernel_version | egrep -c "${MAKE_MATCH[$index]}"` -gt 0 ]; then
	    make_command="${MAKE[$index]}"
	fi
	index=$(($index+1))
    done

    # Use the generic make command if kernel >= 2.5
    if [ -n "$gt2dot4" ]; then
	make_command="make -C /lib/modules/$kernel_version/build SUBDIRS=$dkms_tree/$module/$module_version/build modules"
    fi
    
    # Set modules_conf_array
    index=0
    while [ "$index" -lt "${#MODULES_CONF[*]}" ]; do
	[ -n "${MODULES_CONF[$index]}" ] && modules_conf_array[$index]="${MODULES_CONF[$index]}"
	index=$(($index+1))
    done

    # Set patch_array (including kernel specific patches)
    index=0
    count=0
    while [ "$index" -lt "${#PATCH[*]}" ]; do
	if [ -z "${PATCH_MATCH[$index]}" ] || [ `echo $kernel_version | egrep -c "${PATCH_MATCH[$index]}"` -gt 0 ]; then
	    patch_array[$count]="${PATCH[$index]}"
	    count=$(($count+1))
	fi
	index=$(($index+1))
    done

    # Set remake_initrd
    [ `echo "$REMAKE_INITRD" | grep -ic "^y"` -gt 0 ] && remake_initrd="yes"

    # Fail if no make command
    if [ -z "$make_command" ]; then
	echo $"dkms.conf: Error! No 'MAKE' directive specified.">$std_err
	return_value=1
    fi

    # Fail if absolutely no DEST_MODULE_LOCATION
    if [ "${#dest_module_location[*]}" -eq 0 ]; then
	echo $"dkms.conf: Error! No 'DEST_MODULE_LOCATION' directive specified." >$std_err
	return_value=1
    fi

    # Fail if no PACKAGE_NAME
    if [ -z "$package_name" ]; then
	echo $"dkms.conf: Error! No 'PACKAGE_NAME' directive specified.">$std_err
	return_value=1
    fi

    # Fail if no PACKAGE_VERSION
    if [ -z "$package_version" ]; then
	echo $"dkms.conf: Error! No 'PACKAGE_VERSION' directive specified.">$std_err
	return_value=1
    fi

    # Warn if no clean command
    if [ -z "$clean" ]; then
	echo $"dkms.conf: Warning.  No 'CLEAN' directive specified. Assuming: make clean" >$std_err
	clean="make clean"
    fi

    return $return_value
}

function modulesconf_modify ()
{
    # Make modules.conf changes as necessary
    if [ "$1" == "add" ]; then

	# Add aliases
	if [ -n "$modules_conf_alias_type" ]; then
	    for module_name_after in ${dest_module_name[*]}; do
		if [ `grep -c "alias ${modules_conf_alias_type}[0-9]* $module_name_after\b" /etc/modules.conf` -eq 0 ]; then
		    next_alias_number=$(( `grep "alias $modules_conf_alias_type" /etc/modules.conf | awk '{print $2}' | sed "s/$modules_conf_alias_type//" | sort -n | tail -1` + 1 ))
		    echo -e "alias ${modules_conf_alias_type}${next_alias_number} $module_name_after" >> /etc/modules.conf
		fi
	    done
	fi

	# Add anything else
	index=0
	while [ $index -lt ${#modules_conf_array[*]} ]; do
	    if [ -n "${modules_conf_array[$index]}" ] && [ `grep -c "${modules_conf_array[$index]}" "/etc/modules.conf"` -eq 0 ]; then
		echo -e "${modules_conf_array[$index]}" >> /etc/modules.conf
	    fi	    
	    index=$(($index+1))
	done

    # Remove modules_conf entries from /etc/modules.conf
    elif [ "$1" == "delete" ]; then

	# Remove aliases (maybe)
	if [ -n "$modules_conf_alias_type" ]; then
	    for module_name_after in ${dest_module_name[*]}; do
		if [ `find /lib/modules/$kernel_version/ -name "$module_name_after.*" 2>/dev/null | wc -l | awk '{print $1}'` -eq 0 ]; then
		    grep -v "alias ${modules_conf_alias_type}[0-9]* $module_name_after" /etc/modules.conf > /etc/modules.new
		    mv -f /etc/modules.new /etc/modules.conf
		fi
	    done
	fi

	# Remove everything else
	index=0
	while [ $index -lt ${#modules_conf_array[*]} ]; do
	    if [ -n "${modules_conf_array[$index]}" ]; then
		grep -v "${modules_conf_array[$index]}" "/etc/modules.conf" > /etc/modules.new
		mv -f /etc/modules.new /etc/modules.conf
	    fi	    
	    index=$(($index+1))
	done
    fi
}

function etc_sysconfig_kernel_modify ()
{
    if [ -e "/etc/sysconfig/kernel" ] && [ -n "$remake_initrd" ]; then

        # Make /etc/sysconfig/kernel changes as necessary
	if [ "$1" == "add" ]; then
	    etc_sysconfig_kernel_modify "delete"
	    for module_name_after in ${dest_module_name[*]}; do
		sed -e "s/INITRD_MODULES=\"\(.*\)\"/INITRD_MODULES=\"\1 $module_name_after\"/" /etc/sysconfig/kernel > /etc/sysconfig/kernel.new
		mv /etc/sysconfig/kernel.new /etc/sysconfig/kernel
	    done
	
        # Remove /etc/sysconfig/kernel entries
	elif [ "$1" == "delete" ]; then
	    for module_name_after in ${dest_module_name[*]}; do
		sed -e "s/\(INITRD_MODULES.*\)$module_name_after\b\(.*\)/\1\2/" /etc/sysconfig/kernel > /etc/sysconfig/kernel.new
		mv /etc/sysconfig/kernel.new /etc/sysconfig/kernel
	    done
	fi
    fi
}

function add_module ()
{

    # Set the kernel_version if it remains unset
    if [ -z "$kernel_version" ]; then
	kernel_version="$current_kernel"
    fi

    # Check that we have all the arguments
    if [ -z "$module" ] || [ -z "$module_version" ]; then
	echo $"" >$std_err
	echo $"Error! Invalid number of arguments passed." >$std_err
	echo $"Usage: add [-m module] [-v module-version]" >$std_err
	exit 1
    fi

    if [ -z "$conf" ]; then
	conf="$source_tree/$module-$module_version/dkms.conf"
    fi
	
    # Check that /usr/src/$module-$module_version exists	
    if ! [ -d "$source_tree/$module-$module_version" ]; then
	echo $"" >$std_err
	echo $"Error! Could not find module source directory." >$std_err
	echo $"Directory: $source_tree/$module-$module_version does not exist." >$std_err
	exit 2
    fi

    # Do stuff for --rpm_safe_upgrade
    if [ -n "$rpm_safe_upgrade" ]; then
	pppid=`cat /proc/$PPID/status | grep PPid: | awk {'print $2'}`
	temp_dir_name=`mktemp $tmp_location/dkms_rpm_safe_upgrade_lock.$pppid.XXXXXX 2>/dev/null`
	echo "$module-$module_version" >> $temp_dir_name
	ps -o lstart --no-headers -p $pppid 2>/dev/null >> $temp_dir_name
    fi

    # Check that this module-version hasn't already been added
    if [ -d "$dkms_tree/$module/$module_version" ]; then
	echo $"" >$std_err
	echo $"Error! DKMS tree already contains: $module-$module_version" >$std_err
	echo $"You cannot add the same module/version combo more than once." >$std_err
	exit 3
    fi

    # Check that the conf file exists or any other script specified
    if ! [ -e "$conf" ]; then
	echo $"" >$std_err
	echo $"Error! Could not locate dkms.conf file." >$std_err
	echo $"File: $conf does not exist." >$std_err
	exit 4
    fi

    # Check the conf file for sanity
    read_conf "$conf"
    if [ "$?" -ne 0 ]; then
	echo $"" >$std_err
	echo $"Error! Bad conf file." >$std_err
	echo $"File: $conf does not represent a valid dkms.conf file" >$std_err
	exit 8
    fi
    
    # Create the necessary dkms tree structure
    echo $""
    echo $"Creating symlink $dkms_tree/$module/$module_version/source ->"
    echo $"                 $source_tree/$module-$module_version"
    mkdir -p "$dkms_tree/$module/$module_version/build"
    ln -s "$source_tree/$module-$module_version" "$dkms_tree/$module/$module_version/source"
   
    # Run the post_add script
    if [ -n "$post_add" ] && [ -x "$dkms_tree/$module/$module_version/source/$post_add" ]; then
	echo $"" 
	echo $"Running the post_add script:" 
	"$dkms_tree/$module/$module_version/source/$post_add" 
    fi
    
    echo $"" 
    echo $"DKMS: Add Completed." 
}

function prepare_kernel()
{
    # Set the kernel variables
    [ -z "$kernel_source_dir" ] && kernel_source_dir="/lib/modules/$kernel_version/build"

    # Check that kernel-source exists
    if ! [ -e "$kernel_source_dir/include" ]; then
	echo $"" >$std_err
	echo $"Error! Your kernel source for kernel $kernel_version is not" >$std_err
	echo $"installed. DKMS build requires kernel source to build modules." >$std_err
	exit 1	
    fi

    # Prepare kernel for module build
    echo $"" 
    echo $"Preparing kernel $kernel_version for module build:" 
    echo $"(This is not compiling a kernel, only just preparing kernel symbols)" 
    cd $kernel_source_dir
    config_contents=`cat .config 2>/dev/null`
    [ -n "$config_contents" ] && echo $"Storing current .config to be restored when complete"
    
    # Do preparation
    if [ -f /boot/vmlinuz.version.h ]; then
	echo $"Running UnitedLinux preparation routine"
	kernel_config="/boot/vmlinuz.config"
	invoke_command "make mrproper >/dev/null 2>&1" "make mrproper" background
	[ -n "$config_contents" ] && echo "$config_contents" > .config
	invoke_command "cp /boot/vmlinuz.version.h include/linux/version.h" "using /boot/vmlinux.version.h" 
	invoke_command "cp -f $kernel_config .config" "using $kernel_config" 
	invoke_command "make cloneconfig >/dev/null 2>&1" "make cloneconfig" background
	invoke_command "make CONFIG_MODVERSIONS=1 dep >/dev/null 2>&1" "make CONFIG_MODVERSIONS=1 dep" background
    else 
	echo $"Running Red Hat/Generic preparation routine"
	invoke_command "make mrproper >/dev/null 2>&1" "make mrproper" background
	[ -n "$config_contents" ] && echo "$config_contents" > .config

        # Fix Makefile up so that EXTRAVERSION matches the kernel_version extraversion
	echo $"editing kernel Makefile"
	extraversion=`echo "$kernel_version" | sed 's/.*-/-/'`
	sed "s/EXTRAVERSION *=.*/EXTRAVERSION = $extraversion/" Makefile 2>/dev/null > Makefile.new
	mv -f Makefile.new Makefile
	sed "s/EXTRAVERSION=.*/EXTRAVERSION = $extraversion/" Makefile 2>/dev/null > Makefile.new
	mv -f Makefile.new Makefile

        # If kernel_config is not set, look in default spot for .config (./configs/kernel-...)
	if [ -z "$kernel_config" ] && [ -d "$kernel_source_dir/configs" ]; then
	    arch_used=`uname -m`
	    kernel_trunc=`echo $kernel_version | sed 's/-.*//'`
	    for config_type in debug summit smp enterprise bigmem BOOT; do
		if [ `echo "$kernel_version" | grep "$config_type"` ]; then
		    [ "$config_type" == "BOOT" ] && arch_used="i386"
		    kernel_config="$kernel_source_dir/configs/kernel-$kernel_trunc-$arch_used-$config_type.config"
		fi
	    done
	    [ -z "$kernel_config" ] && kernel_config="$kernel_source_dir/configs/kernel-$kernel_trunc-$arch_used.config"
	fi
	
	# Warn if no config, otherwise use it
	if [ -z "$kernel_config" ]; then
	    echo $""
	    echo $"Warning! Cannot find a .config file to prepare your kernel with."
	    echo $"Try using the --config option to specify where one can be found."
	    echo $"Your build will likely fail because of this."
	else
	    echo $"using $kernel_config"
	    cp -f "$kernel_config" .config
	fi

	invoke_command "make oldconfig >/dev/null 2>&1" "make oldconfig" background
	[ -z "$gt2dot4" ] && invoke_command "make dep >/dev/null 2>&1" "make dep" background
    fi
    cd -
}

function install_module()
{
    # Set the kernel_version if it remains unset
    if [ -z "$kernel_version" ]; then
	kernel_version="$current_kernel"
    fi

    # Check that the right arguments were passed
    if [ -z "$module" ] || [ -z "$module_version" ]; then
	echo $"" >$std_err
	echo $"Error! Invalid number of parameters passed." >$std_err
	echo $"Usage: install [-m module] [-v module-version]" >$std_err
	exit 1
    fi

    # Check that $module-$module_version exists by checking the source symlink	
    if ! [ -d "$dkms_tree/$module/$module_version/source" ]; then
	echo $"" >$std_err
	echo $"Error! DKMS tree does not contain: $module-$module_version" >$std_err
	echo $"Build cannot continue without the proper tree." >$std_err
	exit 2
    fi

    # Make sure that kernel exists to install into
    if ! [ -e "/lib/modules/$kernel_version" ]; then
	echo $"" >$std_err
	echo $"Error! The directory /lib/modules/$kernel_version doesn't exist." >$std_err
	echo $"You cannot install a module onto a non-existant kernel." >$std_err
	exit 6
    fi

    # Read the conf file
    read_conf
    if [ "$?" -ne 0 ]; then
	echo $"" >$std_err
	echo $"Error! Bad conf file." >$std_err
	echo $"File: $dkms_tree/$module/$module_version/source/dkms.conf does not represent" $std_err
	echo $"a valid dkms.conf file." >$std_err
	exit 3
    fi

    # Make sure the $module_name_after exists
    for module_name_after in ${dest_module_name[*]}; do
	if ! [ -e "$dkms_tree/$module/$module_version/$kernel_version/module/$module_name_after$module_suffix" ]; then
    echo $"" >$std_err
	    echo $"Error! Could not locate $module_name_after$module_suffix for module $module in the DKMS tree." >$std_err
	    echo $"You must run a dkms build for kernel $kernel_version first." >$std_err
	    exit 4
	fi
    done

    # Check that its not already installed (kernel symlink)
    readlink "$dkms_tree/$module/kernel-${kernel_version}"
    kernel_symlink="$read_link"
    if [ "$kernel_symlink" == "$module_version/$kernel_version" ]; then
	echo $"" >$std_err
	echo $"Error! This module/version combo is already installed" >$std_err
	echo $"for kernel: $kernel_version" >$std_err
	exit 5
    fi

    # Save the original_module if one exists, none have been saved before, and this is the first module for this kernel
    lib_tree="/lib/modules/$kernel_version"
    count=0
    while [ "$count" -lt "${#built_module_name[*]}" ]; do
	module_count=`find $lib_tree -name ${dest_module_name[$count]}$module_suffix | wc -l | awk {'print $1'}`
	if ! [ -L "$dkms_tree/$module/kernel-$kernel_version" ] && [ "$module_count" -eq 1 ]; then
	    echo $"" 
	    echo $"Found an original module ${dest_module_name[$count]}$module_suffix in /lib/modules/" 
	    echo $"Archiving it within the DKMS tree for uninstallation purposes." 
	    mkdir -p "$dkms_tree/$module/original_module/$kernel_version/"
	    mv -f `find $lib_tree -name ${dest_module_name[$count]}$module_suffix` "$dkms_tree/$module/original_module/$kernel_version/"
	elif  ! [ -L "$dkms_tree/$module/kernel-$kernel_version" ] && [ "$module_count" -gt 1 ] && [ -e "/lib/modules/$kernel_version${dest_module_location[$count]}/${dest_module_name[$count]}$module_suffix" ]; then
	    echo $""
	    echo $"Found multiple original modules ${dest_module_name[$count]}$module_suffix in /lib/modules"
	    echo $"Archiving the one in /lib/modules/$kernel_version${dest_module_location[$count]} for uninstallation purposes."
	    echo $"Warning! Since multiple modules exist with the same name, problems"
	    echo $"may arise."
	    mkdir -p "$dkms_tree/$module/original_module/$kernel_version/"
	    mv -f "/lib/modules/$kernel_version${dest_module_location[$count]}/${dest_module_name[$count]}$module_suffix" "$dkms_tree/$module/original_module/$kernel_version/"
	elif  ! [ -L "$dkms_tree/$module/kernel-$kernel_version" ] && [ "$module_count" -gt 1 ] && ! [ -e "/lib/modules/$kernel_version${dest_module_location[$count]}/${dest_module_name[$count]}$module_suffix" ]; then
	    echo $""
	    echo $"Multiple original modules ${dest_module_name[$count]}$module_suffix exist in /lib/modules"
	    echo $"Due to this confusion, DKMS cannot archive any of them for uninstallation."
	    echo $"Warning! Since multiple modules exist with the same name, problems"
	    echo $"may arise."	    
	else
	    rm -f "/lib/modules/$kernel_version${dest_module_location[$count]}/${dest_module_name[$count]}$module_suffix" 2>/dev/null
	fi

        # Copy module to its location
	echo $""
 	echo $"Copying the new ${dest_module_name[$count]}$module_suffix for $module to /lib/modules/$kernel_version${dest_module_location[$count]}" 
	mkdir -p /lib/modules/$kernel_version${dest_module_location[$count]}
	cp -f "$dkms_tree/$module/$module_version/$kernel_version/module/${dest_module_name[$count]}$module_suffix" "/lib/modules/$kernel_version${dest_module_location[$count]}/${dest_module_name[$count]}$module_suffix"

	count=$(($count + 1))
    done
    
    # Create the kernel-<kernelver> symlink to designate this version as active
    rm -f "$dkms_tree/$module/kernel-$kernel_version" 2>/dev/null
    ln -s "$module_version/$kernel_version" "$dkms_tree/$module/kernel-$kernel_version" 2>/dev/null

    # Run the post_install script
    if [ -n "$post_install" ] && [ -x "$dkms_tree/$module/$module_version/source/$post_install" ]; then
	echo $"" 
	echo $"Running the post_install script:" 
	"$dkms_tree/$module/$module_version/source/$post_install" 
    fi

    # Make modules.conf changes as necessary
    modulesconf_modify "add"
    etc_sysconfig_kernel_modify "add"

    # Run depmod if System.map-<kernel_version> exists
    if [ -e "/boot/System.map-$kernel_version" ]; then
	invoke_command "depmod -a $kernel_version -F /boot/System.map-$kernel_version" "depmod" background 
    fi

    # Do remake_initrd things (save old initrd)
    if [ -n "$remake_initrd" ]; then
	remake_initrd
    fi
     
    echo $"" 
    echo $"DKMS: Install Completed." 
}


function build_module()
{
    # Set the kernel_version if it remains unset
    if [ -z "$kernel_version" ]; then
	kernel_version="$current_kernel"
    fi

    # Check that the right arguments were passed
    if [ -z "$module" ] || [ -z "$module_version" ]; then
	echo $"" >$std_err
	echo $"Error! Invalid number of parameters passed." >$std_err
	echo $"Usage: build [-m module] [-v module-version]" >$std_err
	exit 1
    fi
    
    # Set the kernel variables
    [ -z "$kernel_source_dir" ] && kernel_source_dir="/lib/modules/$kernel_version/build"

    # Check that source symlink works
    if ! [ -d "$dkms_tree/$module/$module_version/source" ]; then
	echo $"" >$std_err
	echo $"Error! DKMS tree does not contain: $module-$module_version" >$std_err
	echo $"Build cannot continue without the proper tree." >$std_err
	exit 2
    fi

    # Check that the module has not already been built for this kernel
    if [ -d "$dkms_tree/$module/$module_version/$kernel_version" ]; then
	echo $"" >$std_err
	echo $"Error! This module/version has already been built on: $kernel_version" >$std_err
	echo $"The directory: $dkms_tree/$module/$module_version/$kernel_version already" >$std_err
	echo $"exists.  Use the dkms remove function before trying to build again." >$std_err
	exit 3
    fi
	
    # Read the conf file
    read_conf
    if [ "$?" -ne 0 ]; then
	echo $"" >$std_err
	echo $"Error! Bad conf file." >$std_err
	echo $"File: $dkms_tree/$module/$module_version/source/dkms.conf does not represent" >$std_err
	echo $"a valid dkms.conf file." >$std_err
	exit 4
    fi
    
    # Prepare the kernel for the module build
    if [ "$1" != "no-prepare-kernel" ]; then
	prepare_kernel
    fi
    
    # Set up temporary build directory for build
    rm -rf "$dkms_tree/$module/$module_version/build"
    cp -rf "$dkms_tree/$module/$module_version/source/" "$dkms_tree/$module/$module_version/build"
    cd "$dkms_tree/$module/$module_version/build"
    echo $"" 
    echo $"Building module:" 

    # Apply any patches
    index=0
    while [ $index -lt ${#patch_array[*]} ]; do
	if ! [ -e "$dkms_tree/$module/$module_version/build/patches/${patch_array[$index]}" ]; then
	    echo $"" >$std_err
	    echo $"Error!  Patch ${patch_array[$index]} as specified in dkms.conf cannot be" >$std_err
	    echo $"found in $dkms_tree/$module/$module_version/build/patches/." >$std_err
	    exit 5
	fi
	invoke_command "patch -p1 < ./patches/${patch_array[$index]}" "applying patch ${patch_array[$index]}"
	if [ "$?" -ne 0 ]; then
	    echo $"" >$std_err
	    echo $"Error! Application of patch ${patch_array[$index]} failed." >$std_err
	    echo $"Check $dkms_tree/$module/$module_version/build/ for more information." >$std_err
	    exit 6
	fi
	index=$(($index+1))
    done

    # Build
    invoke_command "$clean >/dev/null 2>&1" "cleaning build area" background
    echo $"DKMS make.log for $module-$module_version for kernel $kernel_version" >> "$dkms_tree/$module/$module_version/build/make.log"
    echo $"`date`" >> "$dkms_tree/$module/$module_version/build/make.log"
    invoke_command "$make_command >> $dkms_tree/$module/$module_version/build/make.log 2>&1" "$make_command" background

    # Make sure all the modules built successfully
    count=0
    while [ "$count" -lt "${#built_module_name[*]}" ]; do
	if ! [ -e "${built_module_location[$count]}${built_module_name[$count]}$module_suffix" ]; then
	    echo $"" >$std_err
	    echo $"Error!  Module build ${built_module_name[$count]}$module_suffix failed for kernel: $kernel_version" >$std_err
	    echo $"Consult the make.log in the build directory" >$std_err
	    echo $"$dkms_tree/$module/$module_version/build/ for more information." >$std_err
	    exit 7
	fi
	count=$(($count+1))
    done
    cd -

    # Build success, so create DKMS structure for a built module
    mkdir -p "$dkms_tree/$module/$module_version/$kernel_version/log"
    cp -f "$kernel_config" "$dkms_tree/$module/$module_version/$kernel_version/log/"  
    mv -f "$dkms_tree/$module/$module_version/build/make.log" "$dkms_tree/$module/$module_version/$kernel_version/log/make.log" 2>/dev/null   

    # Save a copy of the new module
    mkdir "$dkms_tree/$module/$module_version/$kernel_version/module" >/dev/null
    count=0
    while [ "$count" -lt "${#built_module_name[*]}" ]; do
	cp -f "$dkms_tree/$module/$module_version/build/${built_module_location[$count]}${built_module_name[$count]}$module_suffix" "$dkms_tree/$module/$module_version/$kernel_version/module/${dest_module_name[$count]}$module_suffix" >/dev/null
	count=$(($count+1))
    done

    # Run the post_build script
    if [ -n "$post_build" ] && [ -x "$dkms_tree/$module/$module_version/source/$post_build" ]; then
	echo $"" 
	echo $"Running the post_build script:" 
	"$dkms_tree/$module/$module_version/source/$post_build" 
    fi
    
    # Run the clean commands
    cd "$dkms_tree/$module/$module_version/build"
    invoke_command "$clean >/dev/null 2>&1" "cleaning build area" background
    cd -
    if [ "$1" != "no-prepare-kernel" ] && [ -z $no_clean_kernel ]; then
	cd "$kernel_source_dir"
	invoke_command "make mrproper >/dev/null 2>&1" "cleaning kernel tree (make mrproper)" background
	[ -n "$config_contents" ] && echo "$config_contents" > .config
	cd -
    fi

    # Clean the build directory
    rm -rf "$dkms_tree/$module/$module_version/build/*"

    echo $"" 
    echo $"DKMS: Build Completed." 
}

function do_uninstall()
{
    echo $"" 
    echo $"--- Uninstall Beginning ---" 
    echo $"Module:  $module"  
    echo $"Version: $module_version" 
    echo $"Kernel:  $kernel_version" 
    echo $"---------------------------" 

    # If kernel-<kernelver> symlink points to this module, check for original_module and put it back
    was_active=""
    readlink "$dkms_tree/$module/kernel-${kernel_version}"
    kernel_symlink="$read_link"
    if [ "$kernel_symlink" == "$module_version/$kernel_version" ]; then
	was_active="true"
	echo $"" 
	echo $"Status: Before uninstall, this module version was ACTIVE on this kernel."
	count=0
	while [ "$count" -lt "${#built_module_name[*]}" ]; do
	    echo $""
	    echo $"Deleting ${dest_module_name[$count]}$module_suffix from: /lib/modules/$kernel_version${dest_module_location[$count]}" 
	    rm -f "/lib/modules/$kernel_version${dest_module_location[$count]}/${dest_module_name[$count]}$module_suffix"
	    if [ -e "$dkms_tree/$module/original_module/$kernel_version/${dest_module_name[$count]}$module_suffix" ]; then
		echo $"Archived original_module ${dest_module_name[$count]}$module_suffix found!  Reinstating it under the" 
		echo $"directory: /lib/modules/$kernel_version${dest_module_location[$count]}" 
		cp -f "$dkms_tree/$module/original_module/$kernel_version/${dest_module_name[$count]}$module_suffix" "/lib/modules$kernel_version${dest_module_location[$count]}/" 2>/dev/null
	    else
		echo $"No original module ${dest_module_name[$count]} was found for this module on this kernel." 
		echo $"Use the dkms install command to reinstall any previous module version." 
		
	        # Remove modules_conf entries from /etc/modules.conf
		modulesconf_modify "delete"
	    fi
	    count=$(($count+1))
	done
	rm -f "$dkms_tree/$module/kernel-$kernel_version"
    else
	echo $"" 
	echo $"Status: This module version was INACTIVE for this kernel." 
    fi

    # Run the post_remove script
    if [ -n "$post_remove" ] && [ -x "$dkms_tree/$module/$module_version/source/$post_remove" ]; then
	echo $"" 
	echo $"Running the post_remove script:" 
	"$dkms_tree/$module/$module_version/source/$post_remove" 
    fi

    # Run depmod if System.map-<kernel_version> exists
    if [ -e "/boot/System.map-$kernel_version" ]; then
	echo $""
	invoke_command "depmod -a $kernel_version -F /boot/System.map-$kernel_version" "depmod" background 
    fi
    
    # Do remake_initrd things (remake initrd)
    if [ -n "$remake_initrd" ] && [ -n "$was_active" ]; then
	remake_initrd
    fi

    # Make sure modules.conf still has entries if they got removed above
    modulesconf_modify "add"

    # Delete the original_module if nothing for this kernel is installed anymore
    if [ -d "$dkms_tree/$module/original_module/$kernel_version" ] && [ -n "$was_active" ]; then
	echo $"" 
	echo $"Removing original_module from DKMS tree for kernel $kernel_version" 
	rm -rf "$dkms_tree/$module/original_module/$kernel_version" 2>/dev/null
    fi
    if [ `find "$dkms_tree/$module/original_module" -path "$dkms_tree/$module/original_module/*" 2>/dev/null | wc -l | awk '{print $1}'` -eq 0 ]; then
	rm -rf "$dkms_tree/$module/original_module" 2>/dev/null
    fi
    
    echo $"" 
    echo $"DKMS: Uninstall Completed." 
}

function uninstall_module ()
{
    # Set the kernel_version if it remains unset
    if [ -z "$kernel_version" ]; then
	kernel_version="$current_kernel"
    fi

    # Check that the right arguments were passed
    if [ -z "$module" ] || [ -z "$module_version" ]; then
	echo $"" >$std_err
	echo $"Error! Invalid number of parameters passed." >$std_err
	echo $"Usage: uninstall [-m module] [-v module-version]" >$std_err
	echo $"   or: uninstall [-m module] [-v module-version] [-k kernel-version]" >$std_err
	exit 1
    fi

    # Check that $module is in the dkms tree
    if ! [ -d "$dkms_tree/$module" ]; then
	echo $"" >$std_err
	echo $"Error! There are no instances of module: $module" >$std_err
	echo $"located in the DKMS tree." >$std_err
	exit 2
    fi

    # Make sure that its installed in the first place
    if ! [ -d "$dkms_tree/$module/$module_version" ]; then
	echo $"" >$std_err
	echo $"Error! The module/version combo: $module-$module_version" >$std_err
	echo $"is not located in the DKMS tree." >$std_err
	exit 3
    fi

    # Read the conf file
    read_conf
    if [ "$?" -ne 0 ]; then
	echo $"" >$std_err
	echo $"Error! Bad conf file." >$std_err
	echo $"File: $dkms_tree/$module/$module_version/source/dkms.conf does not represent" >$std_err
	echo $"a valid dkms.conf file." >$std_err
	exit 4
    fi

    # Only do stuff if module/module version is currently installed
    readlink "$dkms_tree/$module/kernel-${kernel_version}"
    kernel_symlink="$read_link"
    if [ "$kernel_symlink" == "$module_version/$kernel_version" ]; then
	do_uninstall
    else
	echo $"" >$std_err
	echo $"Error! The module $module $module_version is not currently installed." >$std_err
	echo $"This module is not currently ACTIVE for kernel $kernel_version." >$std_err
	exit 5
    fi
}

function remove_module ()
{
    # Check that the right arguments were passed
    if [ -z "$module" ] || [ -z "$module_version" ] || $([ -z "$kernel_version" ] && [ -z "$all" ]); then
	echo $"" >$std_err
	echo $"Error! Invalid number of parameters passed." >$std_err
	echo $"Usage: remove [-m module] [-v module-version] --all" >$std_err
	echo $"   or: remove [-m module] [-v module-version] [-k kernel-version]" >$std_err
	exit 1
    fi

    # Check that kernel_version and all aren't both set simultaneously
    if [ -n "$kernel_version" ] && [ -n "$all" ]; then
	echo $"" >$std_err
	echo $"Error!  There is confusion over what to remove." >$std_err
	echo $"You cannot set both --all and specify a kernel-version." >$std_err
	exit 2
    fi

    # Check that $module is in the dkms tree
    if ! [ -d "$dkms_tree/$module/$module_version" ]; then
	echo $"" >$std_err
	echo $"Error! There are no instances of module: $module" >$std_err
	echo $"$module_version located in the DKMS tree." >$std_err
	exit 3
    fi

    # If $kernel_version is set, make sure its there first before removing
    if [ -n "$kernel_version" ] && ! [ -d "$dkms_tree/$module/$module_version/$kernel_version" ]; then
	echo $"" >$std_err
	echo $"Error! There is no instance of $module $module_version" >$std_err
	echo $"for kernel $kernel_version located in the DKMS tree." >$std_err
	exit 4
    fi

    # Do --rpm_safe_upgrade check (exit out and don't do remove if inter-release RPM upgrade scenario occurs)
    if [ -n "$rpm_safe_upgrade" ]; then
	pppid=`cat /proc/$PPID/status | grep PPid: | awk {'print $2'}`
	time_stamp=`ps -o lstart --no-headers -p $pppid 2>/dev/null`
	for lock_file in `ls $tmp_location/dkms_rpm_safe_upgrade_lock.$pppid.* 2>/dev/null`; do
	    lock_head=`head -1 $lock_file 2>/dev/null`
	    lock_tail=`tail -1 $lock_file 2>/dev/null`
	    if [ "$lock_head" == "$module-$module_version" ] && [ "$lock_tail" == "$time_stamp" ] && [ -n "$time_stamp" ]; then
		echo $""
		echo $"DKMS: Remove cancelled because --rpm_safe_upgrade scenario detected."
		rm -f $lock_file
		exit 0
	    fi
	done
    fi

    # Read the conf file
    read_conf
    if [ "$?" -ne 0 ]; then
	echo $"" >$std_err
	echo $"Error! Bad conf file." >$std_err
	echo $"File: $dkms_tree/$module/$module_version/source/dkms.conf does not represent" >$std_err
	echo $"a valid dkms.conf file." >$std_err
	exit 5
    fi

    # If kernel_version is unset, remove all installations of $module_version, otherwise just one kernel
    kernel_list=""
    if [ -z "$kernel_version" ]; then
	kernel_list="`ls $dkms_tree/$module/$module_version | grep -v "build\b" | grep -v "tarball\b" | grep -v "driver_disk\b" | grep -v "rpm\b"`"
    else
	kernel_list="$kernel_version"
    fi

    # Iterate over the kernel_list
    for kernel_in_tree in $kernel_list; do
	if [ -d "$dkms_tree/$module/$module_version/$kernel_in_tree" ] && ! [ -h "$dkms_tree/$module/$module_version/$kernel_in_tree" ]; then
	    kernel_version="$kernel_in_tree"
	    read_conf
	    if [ "$?" -ne 0 ]; then
		echo $"" >$std_err
		echo $"Error! Bad conf file." >$std_err
		echo $"File: $dkms_tree/$module/$module_version/source/dkms.conf does not represent" >$std_err
		echo $"a valid dkms.conf file." >$std_err
		exit 6
	    fi
	    do_uninstall
	    
            # Delete the $kernel_version part of the tree
	    rm -rf "$dkms_tree/$module/$module_version/$kernel_version"
	fi
    done

    # Delete the $module_version part of the tree if no other $module_version/$kernel_version dirs exist
    if [ -z "`find $dkms_tree/$module/$module_version/* -maxdepth 0 -type d | grep -v build$ | grep -v tarball$ | grep -v driver_disk$ | grep -v rpm$`"  ]; then
	echo $"" 
	echo $"------------------------------" 
	echo $"Deleting module version: $module_version" 
	echo $"completely from the DKMS tree." 
	echo $"------------------------------" 
	rm -rf "$dkms_tree/$module/$module_version"
	echo $"Done."
    fi

    # Get rid of any remnant directories if necessary
    if [ `ls "$dkms_tree/$module" | wc -w | awk '{print $1}'` -eq 0 ]; then
	rm -rf "$dkms_tree/$module" 2>/dev/null
       
	# Its now safe to completely remove references in modules.conf
	modulesconf_modify "delete"
	etc_sysconfig_kernel_modify "delete"
    fi
}

show_status ()
{
    # Error if $module_version is set but $module is not
    if [ -n "$module_version" ] && [ -z "$module" ]; then
	echo $"" >$std_err
	echo $"Error! Invalid number of parameters passed." >$std_err
	echo $"Usage: status" >$std_err
	echo $"   or: status [-m module]" >$std_err
	echo $"   or: status [-k kernel-version]" >$std_err
	echo $"   or: status [-m module] [-v module-version]" >$std_err
	exit 1	
    fi

    # Determine which modules to show status for
    status_shown=""
    if [ -n "$module" ]; then
	modules_needing_status="$module"
    else
	for filename in `ls "$dkms_tree"`; do
	    if [ -d "$dkms_tree/$filename" ] && ! [ -h "$dkms_tree/$filename" ]; then
		modules_needing_status="$modules_needing_status $filename"
	    fi
	done
    fi

    # Iterate over the modules
    for module_in_tree in $modules_needing_status; do

	# Make sure its in the tree
	if [ -d "$dkms_tree/$module_in_tree" ]; then
	
	    # Determine which versions to show status for
	    versions_needing_status=""
	    if [ -n "$module_version" ]; then
		versions_needing_status="$module_version"
	    else
		for filename in `ls "$dkms_tree/$module_in_tree"`; do
		    if [ -d "$dkms_tree/$module_in_tree/$filename" ] && ! [ -h "$dkms_tree/$module_in_tree/$filename" ] && [ "$filename" != "original_module" ]; then
			versions_needing_status="$versions_needing_status $filename"
		    fi
		done    
	    fi
	    
	    # Iterate over the versions
	    for version_in_tree in $versions_needing_status; do
		
     	        # Make sure its in the tree
		if [ -d "$dkms_tree/$module_in_tree/$version_in_tree" ]; then
		    
	            # Determine which kernels to show status for
		    kernels_needing_status=""
		    if [ -n "$kernel_version" ]; then
			kernels_needing_status="$kernel_version"
		    else
			for filename in `ls $dkms_tree/$module_in_tree/$version_in_tree | grep -v "build\b" | grep -v "tarball\b" | grep -v "driver_disk\b" | grep -v "rpm\b"`; do
			    if [ -d "$dkms_tree/$module_in_tree/$version_in_tree/$filename" ] && ! [ -h "$dkms_tree/$module_in_tree/$version_in_tree/$filename" ]; then
				kernels_needing_status="$kernels_needing_status $filename"
			    fi
			done    
		    fi

		    # Source in the dkms.conf
		    conf="$dkms_tree/$module_in_tree/$version_in_tree/source/dkms.conf"
		    read_conf $conf

	            # Iterate over the kernels
		    for kernel_in_tree in $kernels_needing_status; do

     	                # Make sure its in the tree
			if [ -d "$dkms_tree/$module_in_tree/$version_in_tree/$kernel_in_tree" ]; then
			    readlink "$dkms_tree/$module_in_tree/kernel-${kernel_in_tree}"
			    kernel_symlink="$read_link"
			    extra_status=""
			    if [ -d "$dkms_tree/$module_in_tree/original_module/$kernel_in_tree" ]; then
				extra_status=" (original_module exists)"
			    fi
			    if [ "$kernel_symlink" == "$version_in_tree/$kernel_in_tree" ]; then
				activity_state="installed"
				count=0
				while [ "$count" -lt "${#dest_module_name[*]}" ]; do
				    if ! `diff "$dkms_tree/$module_in_tree/$version_in_tree/$kernel_in_tree/module/${dest_module_name[$count]}$module_suffix" "/lib/modules/$kernel_in_tree${dest_module_location[$count]}/${dest_module_name[$count]}$module_suffix" >/dev/null 2>&1`; then
					extra_status="$extra_status (WARNING! Diff between built and installed module!)"
				    fi
				    count=$(($count+1))
				done
			    else
				activity_state="built"
				count=0
				while [ "$count" -lt "${#dest_module_name[*]}" ]; do
				    if ! [ -e "$dkms_tree/$module_in_tree/$version_in_tree/$kernel_in_tree/module/${dest_module_name[$count]}$module_suffix" ]; then
					extra_status="$extra_status (WARNING! Missing some built modules!)"
				    fi
				    count=$(($count+1))
				done
			    fi
			    status_shown="true"
			    echo "$module_in_tree, $version_in_tree, $kernel_in_tree: $activity_state$extra_status" 
			fi
			
		    done

		    if [ "$kernels_needing_status" == "" ]; then
			status_shown="true"
			echo "$module_in_tree, $version_in_tree: added" 
		    fi
		    
		fi
		
	    done
	    
	fi
	
    done
    
    if [ -z "$status_shown" ]; then
	echo $"" >$std_err
	echo $"Nothing found within the DKMS tree for this status command." >$std_err
	echo $"If your modules were not installed with DKMS, they will not show up here." >$std_err
    fi
}

make_driver_disk ()
{
    # Check that the right arguments were passed
    if [ -z "$module" ] || [ -z "$module_version" ] || [ -z "$distro" ] || [ -z "$kernel_version" ]; then
	echo $"" >$std_err
	echo $"Error! Invalid number of parameters passed." >$std_err
	echo $"Usage: mkdriverdisk [-d distro] [-m module] [-v module-version] [-k kernel-version]" >$std_err
	exit 1
    fi   

    # Check that source symlink works
    if ! [ -d "$dkms_tree/$module/$module_version/source" ]; then
	echo $"" >$std_err
	echo $"Error! DKMS tree does not contain: $module-$module_version" >$std_err
	echo $"Build cannot continue without the proper tree." >$std_err
	exit 2
    fi

    # Confirm that distro is supported
    if [ "$distro" != "redhat" ]; then
	echo $"" >$std_err
	echo $"Error! Invalid distro argument." >$std_err
	echo $"Currently the only supported distro for this action is: redhat" >$std_err 
	exit 3
    fi

    # Read the conf file
    read_conf
    if [ "$?" -ne 0 ]; then
	echo $"" >$std_err
	echo $"Error! Bad conf file." >$std_err
	echo $"File: $dkms_tree/$module/$module_version/source/dkms.conf does not represent" >$std_err
	echo $"a valid dkms.conf file." >$std_err
	exit 4
    fi

    # Create a list of modules to put into modules.cgz (make sure they exist too)
    kernel_version=`echo $kernel_version | cut -d "," --output-delimiter " " -f 1-`
    kernel_version_list=""
    modules_cgz_list=""
    temp_dir_name=`mktemp -d $tmp_location/dkms.XXXXXX`
    for kernel in $kernel_version; do 
	count=0
	while [ "$count" -lt "${#dest_module_name[*]}" ]; do
	    if ! [ -e "$dkms_tree/$module/$module_version/$kernel/module/${dest_module_name[$count]}$module_suffix" ]; then
		echo $"" >$std_err
		echo $"Error! Cannot find module ${dest_module_name[$count]}$module_suffix for kernel $kernel." >$std_err
		echo $"Module/version must be in built state before making a driver disk." >$std_err
		rm -rf $temp_dir_name
		exit 5
	    fi
	    if [ -z "$kernel_version_list" ]; then
		kernel_version_list="kernel$kernel"
	    else
		kernel_version_list="$kernel_version_list-kernel$kernel"
	    fi
	    mkdir -p $temp_dir_name/$kernel
	    cp "$dkms_tree/$module/$module_version/$kernel/module/${dest_module_name[$count]}$module_suffix" "$temp_dir_name/$kernel/"
	    modules_cgz_list="$kernel/${dest_module_name[$count]}$module_suffix\n${modules_cgz_list}"
	    count=$(($count+1))
	done
    done

    # Create directory and necessary files
    mkdir -p "$dkms_tree/$module/$module_version/driver_disk"
   
    # Copy files for the driver disk (or warn if not present)
    files_for_driverdisk="module-info disk-info modules.dep pcitable"
    files_into_driverdisk="modules.cgz"
    for file in $files_for_driverdisk; do
	if ! [ -e "$dkms_tree/$module/$module_version/source/redhat_driver_disk/$file" ]; then
	    echo $"Warning! File: $file not found in $dkms_tree/$module/$module_version/source/redhat_driver_disk/" >$std_err
	else
	    files_into_driverdisk="$file $files_into_driverdisk"
	    cp -f "$dkms_tree/$module/$module_version/source/redhat_driver_disk/$file" "$dkms_tree/$module/$module_version/driver_disk/" 2>/dev/null
	fi
    done
    touch "$dkms_tree/$module/$module_version/driver_disk/rhdd-6.1"

    # Create dos disk image
    image_name="$module-$module_version-$kernel_version_list-dd.img"  
    echo $""
    echo $"Creating driver disk:"
    cd $temp_dir_name
    invoke_command "echo -e '$modules_cgz_list' | cpio -oH crc 2>/dev/null | gzip -9 > ./modules.cgz" "compressing modules.cgz" background
    cp -f ./modules.cgz "$dkms_tree/$module/$module_version/driver_disk/"
    cd -
    rm -rf $temp_dir_name
    cd "$dkms_tree/$module/$module_version/driver_disk/"
    rm -f $image_name
    invoke_command "dd if=/dev/zero of="./$image_name" bs=72k count=20 >/dev/null 2>&1" "making a blank floppy image" background
    invoke_command "mkdosfs ./$image_name >/dev/null 2>&1" "mkdosfs" background
    mkdir ./mnt
    invoke_command "mount -o loop $image_name ./mnt >/dev/null 2>&1" "loopback mounting disk image"
    for file in $files_into_driverdisk; do
	invoke_command "cp -f ./$file ./mnt/" "  copying $file to disk image"
    done
    invoke_command "umount ./mnt" "unmounting disk image"
    rm -rf ./mnt
    cd -
    echo $""
    echo $"Disk image location: $dkms_tree/$module/$module_version/driver_disk/$image_name"
    echo $""
    echo $"Done."
}

make_tarball()
{
    # Error if $module_version is set but $module is not
    if [ -z "$module" ] || [ -z "$module_version" ]; then
	echo $"" >$std_err
	echo $"Error! Invalid number of parameters passed." >$std_err
	echo $"Usage: mktarball [-m module] [-v module-version]" >$std_err
	exit 1	
    fi

    # Check that source symlink works
    if ! [ -d "$dkms_tree/$module/$module_version/source" ]; then
	echo $"" >$std_err
	echo $"Error! DKMS tree does not contain: $module-$module_version" >$std_err
	echo $"Build cannot continue without the proper tree." >$std_err
	exit 2
    fi

    # Make sure that its installed in the first place
    if ! [ -d "$dkms_tree/$module/$module_version" ]; then
	echo $"" >$std_err
	echo $"Error! The module/version combo: $module-$module_version" >$std_err
	echo $"is not located in the DKMS tree." >$std_err
	exit 3
    fi

    # Create a list of possible built kernels for this module
    built_for_kernels=`dkms status -m $module -v $module_version | awk '{print $3}' | grep ":" | sed 's/://'`

    if [ -z "$built_for_kernels" ]; then
	echo $"" >$std_err
	echo $"Error!  There are no built modules for any kernels for $module" >$std_err
	echo $"$module_version.  Cannot create an empty tarball." >$std_err
	exit 4
    fi

    # Read the conf file
    read_conf
    if [ "$?" -ne 0 ]; then
	echo $"" >$std_err
	echo $"Error! Bad conf file." >$std_err
	echo $"File: $dkms_tree/$module/$module_version/source/dkms.conf does not represent" >$std_err
	echo $"a valid dkms.conf file." >$std_err
	exit 5
    fi

    # If they specified a kernel(s), make sure everything is sane
    kernel_version=`echo $kernel_version | cut -d "," --output-delimiter " " -f 1-`
    for kernel in $kernel_version; do
	if [ `echo "$built_for_kernels" | grep -c "$kernel$"` -eq 0 ]; then
	    echo $"" >$std_err
	    echo $"Error! The kernel $kernel does not have modules built for" >$std_err
	    echo $"$module $module_version.  Cannot create archive." >$std_err
	    exit 6
	fi
    done

    # Create a temp directory and populate it
    temp_dir_name=`mktemp -d $tmp_location/dkms.XXXXXX`
    mkdir -p $temp_dir_name/dkms_source_tree
    mkdir -p $temp_dir_name/dkms_main_tree

    # Copy the source_tree
    echo $""
    echo $"Marking $source_tree/$module-$module_version for archiving..."
    cp -rf $source_tree/$module-$module_version/* $temp_dir_name/dkms_source_tree

    # Determine the kernel_versions to put in the tarball
    kernel_version_list=""
    for kernel in $built_for_kernels; do
	if [ -z "$kernel_version" ] || [ `echo "$kernel_version" | grep -c "$kernel\b"` -gt 0 ]; then
	    if [ -z "$kernel_version_list" ]; then
		kernel_version_list="kernel$kernel"
	    else
		kernel_version_list="$kernel_version_list-kernel$kernel"
	    fi
	    echo $"Marking kernel $kernel for archiving..."
	    cp -rf "$dkms_tree/$module/$module_version/$kernel" $temp_dir_name/dkms_main_tree/
	fi
    done

    # Make the tarball
    cd $temp_dir_name
    tar -czf $temp_dir_name/$module-$module_version-$kernel_version_list.dkms.tar.gz ./* 2>/dev/null
    cd -
    if [ "$?" -eq 0 ]; then
	mkdir -p $dkms_tree/$module/$module_version/tarball
	mv -f $temp_dir_name/$module-$module_version-$kernel_version_list.dkms.tar.gz $dkms_tree/$module/$module_version/tarball/
	echo $""
	echo $"Tarball location: $dkms_tree/$module/$module_version/tarball/$module-$module_version-$kernel_version_list.dkms.tar.gz"
	echo $""
	echo $"Done."
	rm -rf $temp_dir_name
    else
	echo $"" >$std_err
	echo $"Error! Failed to make tarball." >$std_err
	rm -rf $temp_dir_name
	exit 6
    fi
}

load_tarball()
{
    # Error out of --config was not set with the tarball location
    if [ -z "$archive_location" ]; then
	echo $"" >$std_err
	echo $"Error! Invalid number of parameters passed." >$std_err
	echo $"Usage: ldtarball [--archive=tarball-location]" >$std_err
	exit 1	
    fi

    # Error out if $archive_location does not exist
    if ! [ -e "$archive_location" ]; then
	echo $"" >$std_err
	echo $"Error! Cannot locate $archive_location." >$std_err
	echo $"File does not exist." >$std_err
	exit 2
    fi

    # Figure out what kind of archive it is (tar.gz, tar, tar.bz, etc)
    tar_options=""
    if `gzip -t $archive_location 2>/dev/null`; then
	tar_options="${tar_options}z"
    fi
    if `bzip2 -t $archive_location 2>/dev/null`; then
	tar_options="${tar_options}j"
    fi

    # Untar it into $tmp_location
    temp_dir_name=`mktemp -d $tmp_location/dkms.XXXXXX`
    tar -${tar_options}xf $archive_location -C $temp_dir_name 

    # Make sure its a sane tarball
    PACKAGE_NAME=""
    PACKAGE_VERSION=""
    is_from_mktarball=""
    if ! [ -d "$temp_dir_name/dkms_source_tree" ]; then
	conf=`find $temp_dir_name/ -name dkms.conf 2>/dev/null | head -1`
	if [ -z "$conf" ]; then
	    echo $"" >$std_err
	    echo $"Error! Tarball does not appear to be a correctly formed" >$std_err
	    echo $"DKMS archive. No dkms.conf found within it." >$std_err
	    rm -rf $temp_dir_name
	    exit 3
	fi
	read_conf "$conf"
	if [ "$?" -ne 0 ]; then
	    echo $"" >$std_err
	    echo $"Error! Bad conf file." >$std_err
	    echo $"File: $conf does not represent a valid dkms.conf file" >$std_err
	    rm -rf $temp_dir_name
	    exit 4
	fi
	tarball_source_tree_name=`echo $conf | sed "s#$temp_dir_name\/##" | sed 's/dkms.conf//' | sed 's/\/$//'`
    else
	. $temp_dir_name/dkms_source_tree/dkms.conf 2>/dev/null
	if [ -z "$PACKAGE_NAME" ] || [ -z "$PACKAGE_VERSION" ] || ! [ -d "$temp_dir_name/dkms_main_tree" ]; then
	    echo $"" >$std_err
	    echo $"Error! Tarball does not appear to be a correctly formed" >$std_err
	    echo $"DKMS archive." >$std_err
	    rm -rf $temp_dir_name
	    exit 5
	fi
	is_from_mktarball="true"
	tarball_source_tree_name="dkms_source_tree"
    fi
    module="$PACKAGE_NAME"
    module_version="$PACKAGE_VERSION"

    echo $""
    echo $"Loading tarball for module: $module / version: $module_version"
    echo $""

    # Load the source from the tarball
    if [ "`dkms status -m $module -v $module_version 2>/dev/null`" != "" ] && [ -z "$force" ]; then
	echo $"Warning! Source for $module-$module_version already exists.  Skipping..."
    else
	echo $"Loading $source_tree/$module-$module_version..."
	rm -rf $source_tree/$module-$module_version
	mkdir -p $source_tree/$module-$module_version
	cp -rf $temp_dir_name/$tarball_source_tree_name/* $source_tree/$module-$module_version
    fi

    mkdir -p $dkms_tree/$module/$module_version

    # Load kernel directories
    dirs_to_load=`find $temp_dir_name/dkms_main_tree -type d -maxdepth 1 -mindepth 1 2>/dev/null`
    for directory in $dirs_to_load; do
	dkms_dir_location="$dkms_tree/$module/$module_version/`echo $directory | sed 's/.*\///'`"
	if [ -d "$dkms_dir_location" ] && [ -z "$force" ]; then
	    echo $"Warning! $dkms_dir_location already exists.  Skipping..."
	else
	    echo $"Loading $dkms_dir_location..."
	    rm -rf $dkms_dir_location
	    mkdir -p $dkms_dir_location
	    cp -rf $directory/* $dkms_dir_location
	fi
    done
    
    # Create source symlink
    if [ -h "$dkms_tree/$module/$module_version/source" ] && [ -z "$force" ]; then
	echo $"Warning! $dkms_tree/$module/$module_version/source already exists.  Skipping..."
    else
	echo $"Creating $dkms_tree/$module/$module_version/source symlink..."
	rm -f "$dkms_tree/$module/$module_version/source"
	ln -s "$source_tree/$module-$module_version" "$dkms_tree/$module/$module_version/source"
    fi
    
    # Clean up /tmp
    rm -rf $temp_dir_name
}

run_match ()
{
    # Error if $template_kernel or $kernel_version are unset
    if [ -z "$template_kernel" ] || [ -z "$kernel_version" ]; then
	echo $"" >$std_err
	echo $"Error! Invalid number of parameters passed." >$std_err
	echo $"Usage: match [--templatekernel=kernel-version] [-k kernel-version]" >$std_err
	echo $"   or: match [--templatekernel=kernel-version] [-k kernel-version] [-m module]" >$std_err
	exit 1	
    fi  

    # Error out if $template_kernel = $kernel_version
    if [ "$template_kernel" == "$kernel_version" ]; then
	echo $"" >$std_err
	echo $"Error! The templatekernel and the specified kernel version are the same." >$std_err
	exit 2
    fi

    # Set the IFS to split on new-lines and not on spaces
    IFS='
'
    # Read in the status of template_kernel
    template_kernel_status=`$0 status -k $template_kernel | grep ": installed"`
    
    # If $module is set, grep the status only for that module
    if [ -n "$module" ]; then

        # Make sure that its installed in the first place
	if ! [ -d "$dkms_tree/$module/" ]; then
	    echo $"" >$std_err
	    echo $"Error! The module: $module is not located in the DKMS tree." >$std_err
	    unset IFS
	    exit 3
	fi

	template_kernel_status=`echo "$template_kernel_status" | grep "^$module,"`
    fi

    echo $""
    echo $"Matching modules in kernel: $kernel_version" 
    echo $"to the configuration of kernel: $template_kernel" 

    # Prepare the kernel just once but only if there is actual work to do
    if [ "$template_kernel_status" == "" ]; then
	echo $""
	echo $"There is nothing to be done for this match."
    else
	prepare_kernel

        # Iterate over the kernel_status and match kernel to the template_kernel
	for template_line in $template_kernel_status; do
	    template_module=`echo "$template_line" | sed 's/\(.*\), .*, .*:.*/\1/'`
	    template_version=`echo "$template_line" | sed 's/.*, \(.*\), .*: .*/\1/'`
	    
	    # Print out a match header
	    echo $"" 
	    echo $"---- Match Beginning ----" 
	    echo $"Module:  $template_module"  
	    echo $"Version: $template_version" 
	    echo $"-------------------------" 
	    
	    # Figure out what to do from here
	    if [ `$0 status -m "$template_module" -v "$template_version" -k "$kernel_version" 2>/dev/null | grep -c ": installed"` -eq 1 ]; then
		echo $"" 
		echo $"This module/version combo is already installed.  Nothing to be done." 
	    elif [ `$0 status -m "$template_module" -v "$template_version" -k "$kernel_version" 2>/dev/null | grep -c ": built"` -eq 1 ]; then
		unset IFS
		echo $"" 
		echo $"This module/version combo is built.  Installing it:" 
		module="$template_module"
		module_version="$template_version"
		install_module
		IFS='
'
	    else
		unset IFS
		echo $"" 
		echo $"Building & Installing this module/version:" 
		module="$template_module"
		module_version="$template_version"
		build_module "no-prepare-kernel"
		install_module
		IFS='
'
	    fi
	done
    fi

    # Return the IFS to its old state
    unset IFS

    # Clean up the kernel tree
    cd "/lib/modules/$kernel_version/build"
    invoke_command "make mrproper >/dev/null 2>&1" "Cleaning kernel tree (make mrproper)" background
    if [ -n "$config_contents" ]; then
	echo "$config_contents" > .config
    fi
    cd -
    
    # Done
    echo $"" 
    echo $"Match Completed."
}

#############################
####                     #### 
#### Program Starts Here ####
####                     ####
#############################

# Set important variables
current_kernel=`uname -r`
dkms_tree="/var/dkms"
source_tree="/usr/src"
tmp_location="/tmp"
dkms_frameworkconf="/etc/dkms_framework.conf"

# Source in /etc/dkms_framework.conf
. /etc/dkms_framework.conf 2>/dev/null

# Clear out command line argument variables
module=""
module_version=""
kernel_version=""
template_kernel=""
distro=""
conf=""
kernel_config=""
archive_location=""
kernel_source_dir=""
action=""
force=""
no_prepare_kernel=""
no_clean_kernel=""
all=""
gt2dot4=""
module_suffix=""
rpm_safe_upgrade=""
std_err="/dev/stderr"

# Set up arrays
declare -a directive_array

# Parse command line arguments
action_flag=""
while [ $# -gt 0 ]; do
    case $1 in
	--module*|-m)
	    if echo $1 | grep '=' >/dev/null ; then
		module=`echo $1 | sed 's/^.*=//'`
            else
                module="$2"
                shift
            fi
            ;;
	-v)
	    if echo $1 | grep '=' >/dev/null ; then
		module_version=`echo $1 | sed 's/^.*=//'`
            else
                module_version="$2"
                shift
            fi
            ;;
	--kernelver*|-k)
	    if echo $1 | grep '=' >/dev/null ; then
		kernel_version=`echo $1 | sed 's/^.*=//'`
            else
                kernel_version="$2"
                shift
            fi
            ;;
	--distro*|-d)
	    if echo $1 | grep '=' >/dev/null ; then
		distro=`echo $1 | sed 's/^.*=//'`
	    else
		distro="$2"
		shift
	    fi
	    ;;
	--templatekernel*)
	    if echo $1 | grep '=' >/dev/null ; then
		template_kernel=`echo $1 | sed 's/^.*=//'`
            else
                template_kernel="$2"
                shift
            fi
            ;;
	-c)
	    if echo $1 | grep '=' >/dev/null ; then
		conf=`echo $1 | sed 's/^.*=//'`
            else
                conf="$2"
                shift
            fi
            ;;
	--quiet|-q)
	    exec >/dev/null 2>&1
	    ;;
	--version|-V)
	    echo $"dkms: 0.40.11"
	    exit 0
	    ;;
	--no-prepare-kernel)
	    no_prepare_kernel="no-prepare-kernel"
	    ;;
	--no-clean-kernel)
	    no_clean_kernel="no-clean-kernel"
	    ;;
	--force)
	    force="true"
	    ;;
	--all)
	    all="true"
	    ;;
	--rpm_safe_upgrade)
	    rpm_safe_upgrade="true"
	    ;;
	--dkmstree*)
	    if echo $1 | grep '=' >/dev/null ; then
		dkms_tree=`echo $1 | sed 's/^.*=//'`
            else
                dkms_tree="$2"
                shift
            fi
            ;;
	--sourcetree*)
	    if echo $1 | grep '=' >/dev/null ; then
		source_tree=`echo $1 | sed 's/^.*=//'`
            else
                source_tree="$2"
                shift
            fi
            ;;
	--config*)
	    if echo $1 | grep '=' >/dev/null ; then
		kernel_config=`echo $1 | sed 's/^.*=//'`
            else
                kernel_config="$2"
                shift
            fi
	    ;;
	--archive*)
	    if echo $1 | grep '=' >/dev/null ; then
		archive_location=`echo $1 | sed 's/^.*=//'`
            else
                archive_location="$2"
                shift
            fi
	    ;;
	--kernelsourcedir*)
	    if echo $1 | grep '=' >/dev/null ; then
		kernel_source_dir=`echo $1 | sed 's/^.*=//'`
            else
                kernel_source_dir="$2"
                shift
            fi
	    ;;
	--directive*)
	    if echo $1 | grep '=' >/dev/null ; then
		directive_array[${#directive_array[*]}]=`echo $1 | sed 's/[^=]\+=//'`
            else
                directive_array[${#directive_array[*]}]="$2"
                shift
            fi
	    ;;
	-*|--*)
	    echo $"" >&2
	    echo $"Error!  Unknown option: $1" >&2
	    show_usage
	    exit 2
	    ;;
	*)
	    if [ -n "$action_flag" ]; then
		echo $"" >&2
		echo $"Error!  Multiple actions specified: $action, $1" >&2
		show_usage
		exit 3
	    fi
	    action_flag="set"
	    action="$1"
	    ;;
    esac
    shift
done

# Set some variables
kernel_test="$kernel_version"
[ -z "$kernel_test" ] && kernel_test=`uname -r`
[ `echo "$kernel_test" | cut -d "." -f 1-1` -gt 1 ] && [ `echo "$kernel_test" | cut -d "." -f 2-2` -gt 4 ] && gt2dot4="true"
[ -z "$gt2dot4" ] && module_suffix=".o"
[ -n "$gt2dot4" ] && module_suffix=".ko"

# Run the specified action
case "$action" in
    start)
        # ignore
	;;
    stop)
	# ignore
	;;
    add)
	add_module
	;;
    remove)
	# Make sure they're root
	if [ `id -u` -ne 0 ]; then
	    echo $"You must be root to use this command." >$std_err
	    exit 1
	fi
	remove_module
	;;
    build)
	build_module $no_prepare_kernel
	;;
    install)
        # Make sure they're root
	if [ `id -u` -ne 0 ]; then
	    echo $"You must be root to use this command." >$std_err
	    exit 1
	fi
	install_module
	;;
    match)
	# Make sure they're root
	if [ `id -u` -ne 0 ]; then
	    echo $"You must be root to use this command." >$std_err
	    exit 1
	fi
	run_match
	;;
    uninstall)
	# Make sure they're root
	if [ `id -u` -ne 0 ]; then
	    echo $"You must be root to use this command." >$std_err
	    exit 1
	fi
	uninstall_module
	;;
    mkdriverdisk)
	# Make sure they're root
	if [ `id -u` -ne 0 ]; then
	    echo $"You must be root to use this command." >$std_err
	    exit 1
	fi
	make_driver_disk
	;;	
    mktarball)
	make_tarball
	;;	
    ldtarball)
	# Make sure they're root
	if [ `id -u` -ne 0 ]; then
	    echo $"You must be root to use this command." >$std_err
	    exit 1
	fi
	load_tarball
	;;
    status)
	show_status
	;;
    "")
	echo "" >&2
	echo $"Error! No action was specified.">$std_err
	show_usage
	;;
    *)
	echo "" >&2
	echo $"Error! Unknown action specified: $action" >$std_err
	show_usage
	;;
esac
